<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JingyuJung&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://monibu1548.github.io/"/>
  <updated>2019-10-06T01:36:27.178Z</updated>
  <id>http://monibu1548.github.io/</id>
  
  <author>
    <name>Jingyu Jung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[iOS] iOS개발 시 주의해야 할 http status code (클라이언트 개발자도 http를 잘 알아야한다)</title>
    <link href="http://monibu1548.github.io/2019/10/06/ios-http-status-code/"/>
    <id>http://monibu1548.github.io/2019/10/06/ios-http-status-code/</id>
    <published>2019-10-06T00:44:43.000Z</published>
    <updated>2019-10-06T01:36:27.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS개발-시-주의해야-할-http-status-code-feat-301-205"><a href="#iOS개발-시-주의해야-할-http-status-code-feat-301-205" class="headerlink" title="iOS개발 시 주의해야 할 http status code (feat. 301, 205)"></a>iOS개발 시 주의해야 할 http status code (feat. 301, 205)</h1><p>iOS앱을 개발하면서 서버와 통신을 통해 데이터를 가져오는 작업을 하게 됩니다. API 명세에서 response body도 중요하지만 status code도 주의 깊게 살펴봐야 합니다.<br>status code를 잘못 사용하면, <code>앱 삭제후 재설치</code> 등 사용자 경험에 치명적인 이슈가 발생할 수 있습니다.</p><h2 id="iOS개발에서의-HTTP"><a href="#iOS개발에서의-HTTP" class="headerlink" title="iOS개발에서의 HTTP"></a>iOS개발에서의 HTTP</h2><p>http에 대한 설명은 위키백과를 참고해주세요. <a href="https://ko.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP에 대한 이해</a><br>http프로토콜은 위 백과의 내용을 보시면 굉장히 양이 많고 복잡함을 알 수 있습니다. 그렇기 때문에 대부분 Obj-C의 경우 AFNetworking, Swift의 경우 Alamofire 라이브러리를 이용해 쉽게 response를 가져오고 사용할 수 있도록 개발하고 있습니다.<br>위 라이브러리 덕분에 http에 대한 이해도가 부족하더라도 iOS에서 http를 쉽게 사용하여 개발할 수 있지만, 조금 더 나은 iOS개발자가 되기 위해서 주의해야 하는 http status code 정도는 알아둬야 하지 않나 생각합니다.</p><h2 id="iOS앱을-망칠-수-있는-status-code"><a href="#iOS앱을-망칠-수-있는-status-code" class="headerlink" title="iOS앱을 망칠 수 있는 status code"></a>iOS앱을 망칠 수 있는 status code</h2><p>필자가 iOS앱을 개발하면서 잘못된 http status code로 인해 <code>앱 삭제 후 재설치</code>, <code>API 응답 지연</code> 등 사용성에 크리티컬한 이슈를 때려 맞았던 status code와 대응방안을 공유합니다.<br><a href="https://httpstatuses.com/" target="_blank" rel="noopener">http status code 스펙을 볼 수 있는 사이트 https://httpstatuses.com/</a></p><h3 id="301-Moved-Permanently-영구적-리다이렉트"><a href="#301-Moved-Permanently-영구적-리다이렉트" class="headerlink" title="301 (Moved Permanently) 영구적 리다이렉트"></a>301 (Moved Permanently) 영구적 리다이렉트</h3><p><a href="https://httpstatuses.com/301" target="_blank" rel="noopener">301 spec</a></p><p><em>이슈가 발생되는 상황</em><br>301로 잘못된 url을 내려 받는 경우. 서버 복잡도가 높은 경우 gateway를 두고 여러 서버로 redirect를 해주는 구조를 갖게 되는데요. 이 때 gateway의 잘못된 배포로 http 301 code와 함께 잘못된 url이 내려온다면? 앞으로 잘못된 url로 매번 request를 보내며, 매번 실패합니다.</p><p><em>특이사항</em><br>301의 의미, Moved Permanently 말 그대로 301 code로 내려받은 url의 생존주기는 앱의 생존주기와 동일합니다. 앱이 삭제 후 재설치 되지 않는 이상 절대 변경되지 않습니다. (Andorid의 경우 불행중 다행인지 표준을 지키지 않아, 몇시간, 몇일 뒤 잘못된 url이 휘발됩니다.)</p><p>디버깅이 굉장히 어렵습니다. 코드상에서는 없는 url, 잘못된 url로 계속 request를 보내고 있는데, 왜 보내는지 알 방법이 없고 프록시로 요청을 뜯어보지 않는이상 잘못된 url조차도 알 수 없습니다. ~Charles 만세~</p><p>API 응답이 정상적으로 오지 않고, 프록시 확인 결과 잘못된 URL, 클라이언트 코드 상에 없는 잘못된 URL로 계속 요청을 보내고 있다면 301로 잘못된 response를 받은 적이 있는지 확인보세요.</p><p><em>올바른 사용법</em><br>301를 대체할만한 status code로 <code>302</code>, <code>307</code>가 있습니다. <a href="https://httpstatuses.com/302" target="_blank" rel="noopener">302 spec</a>, <a href="https://httpstatuses.com/307" target="_blank" rel="noopener">307 spec</a><br>302는 일회용 리다이렉트라고 생각하면 됩니다. 클라이언트 내부적으로 url을 저장하지 않으므로 잘못된 요청이 오더라도 수정이 가능합니다.<br>307도 302와 기본적인 동작은 동일합니다. 다른점은, redirect될 때 http method 변경은 불가합니다.</p><h2 id="205-Reset-Content-새-문서-없음-하지만-브라우저는-문서-창을-리셋해야-함"><a href="#205-Reset-Content-새-문서-없음-하지만-브라우저는-문서-창을-리셋해야-함" class="headerlink" title="205 (Reset Content)     새 문서 없음. 하지만 브라우저는 문서 창을 리셋해야 함."></a>205 (Reset Content)     새 문서 없음. 하지만 브라우저는 문서 창을 리셋해야 함.</h2><p><a href="https://httpstatuses.com/205" target="_blank" rel="noopener">205 spec</a></p><p><em>이슈가 발생되는 상황</em><br><code>205</code> status code는 직접적으로 영향을 주는 것은 아니지만 iOS의 속성과 합쳐져 이슈를 발생시킬 수 있습니다.</p><h3 id="1-205의-잘못된-사용"><a href="#1-205의-잘못된-사용" class="headerlink" title="1. 205의 잘못된 사용"></a>1. 205의 잘못된 사용</h3><p>status code <code>205</code> 를 사용하는 response의 header의 content-length가 <code>0</code>이 아닌 경우.<br>iOS는 response header의 content-length가 <code>0</code>이 아닌 경우, body를 읽습니다. body가 content-length 값보다 작은 경우 iOS는 body 데이터를 기다립니다… 기다리다가 timeout 시간(default 60sec)이 지나면 timeout으로 connection이 닫히게 됩니다.</p><p>위 상황에서 발생하는 현상은, <code>205</code> status code를 주는 API를 호출 할 때마다 60sec 짜리 connection이 생성됩니다. 각각의 connection은 timeout 시간(default 60sec) 에 도달할 때까지 유지됩니다. (Hang이 걸린다고 표현하죠)</p><h3 id="2-iOS의-기본-속성"><a href="#2-iOS의-기본-속성" class="headerlink" title="2. iOS의 기본 속성"></a>2. iOS의 기본 속성</h3><p><a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1407597-httpmaximumconnectionsperhost" target="_blank" rel="noopener">Swift httpMaximumConnectionsPerHost 프로퍼티</a><br>iOS에는 httpMaximumConnectionsPerHost라는 프로퍼티가 있습니다. host별로 가질 수 있는 동시 connection 수 입니다. iOS의 경우 <code>4</code>를 기본값으로 가집니다.<br>각 host에 동일한 connection이 5개가 생성되면 5번째 request는 무시됩니다. (아예 요청조차 하지 않음)</p><h3 id="1-2-Bomb"><a href="#1-2-Bomb" class="headerlink" title="1 + 2 = Bomb"></a>1 + 2 = Bomb</h3><p>위에서 설명한 1, 2를 더하면..? 폭탄이 됩니다.<br>60sec 짜리 connection 4개가 생성된 이후에 클라이언트는 어떠한 API도 호출하지 않습니다. 보통 response를 보고 UI를 그리거나, 에러페이지를 그리지만,, request조차 하지 않는 API에서는 답이 없습니다.</p><p><em>특이사항</em><br><code>205</code>로 response를 내려받은 상황이기 때문에, 클라이언트앱은 정상적으로 response를 완료했다고 판단합니다. (200 번대 status code).<br>Android의 경우, 동시 connection 제한이 없는지 위의 이슈가 발생하지 않았습니다.</p><p><em>올바른 사용법</em><br><code>205</code>의 스펙을 지키면 됩니다. <a href="https://httpstatuses.com/205" target="_blank" rel="noopener">205 spec</a><br>위 링크에 잘 정리되어 있지만 여기에도 적어보자면</p><ol><li>Header의 Content-Length 값은 <code>0</code> 이어야 합니다.</li><li>그에 맞춰 실제 Body의 데이터는 없어야 합니다.</li></ol><h1 id="HTTP를-잘-쓰는-iOS-개발자"><a href="#HTTP를-잘-쓰는-iOS-개발자" class="headerlink" title="HTTP를 잘 쓰는 iOS 개발자"></a>HTTP를 잘 쓰는 iOS 개발자</h1><p>이번에 소개한 205, 301외에도 주의해야 하는 status code가 더 있을 수 있습니다. (아직 제가 모든 status code를 사용해보지 못했습니다).<br>새로운 API를 연동할 때, 명세에 status code가 새로운 것이 있다면 꼭!  (<a href="https://httpstatuses.com)[https://httpstatuses.com]" target="_blank" rel="noopener">https://httpstatuses.com)[https://httpstatuses.com]</a> 에서 스펙을 확인 하신 후 표준에 맞춰 개발하시기 바랍니다.</p>]]></content>
    
    <summary type="html">
    
      iOS개발 시 주의해야 할 http status code (feat. 301, 205)
iOS앱을 개발하면서 서버와 통신을 통해 데이터를 가져오는 작업을 하게 됩니다. API 명세에서 response body도 중요하지만 status code도 주의 깊게 살펴봐야 합니다.
status code를 잘못 사용하면, 앱 삭제후 재설치 등 사용자 경험에 치명적인 이슈가 발생할 수 있습니다.

iOS개발에서의 HTTP
http에 대한 설명은 위키백과를 참고해주세요. HTTP에 대한 이해
http프로토콜은 위 백과의 내용을 보시면 굉장히 양이
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>[iOS] SQLite3 Database 스키마 버전 관리의 필요성 및 방법 소개</title>
    <link href="http://monibu1548.github.io/2019/03/31/database-versioning/"/>
    <id>http://monibu1548.github.io/2019/03/31/database-versioning/</id>
    <published>2019-03-31T10:31:20.000Z</published>
    <updated>2019-03-31T11:05:03.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Database-SQLite3에-스키마-버전관리가-필요한-이유"><a href="#Database-SQLite3에-스키마-버전관리가-필요한-이유" class="headerlink" title="Database SQLite3에 스키마 버전관리가 필요한 이유"></a>Database SQLite3에 스키마 버전관리가 필요한 이유</h2><p>앱에 신규 기능을 추가하다 보면 Database(SQLite3) 스키마에 변경이 필요한 경우가 생깁니다. 예를 들면, 현재 토이 프로젝트 “퇴근요정” 은 아래와 같은 테이블을 갖고 있습니다.</p><p><img src="../../../../images/sqlite3-versioning/1.png" alt=""></p><p>각 근무시간의 PK인 id, 근무 시작시간 start, 근무 종료시간 end, 이렇게 3개의 column을 갖고 있습니다.</p><p>이번 v1.7 에서는 각 근무에 대한 특이사항 및 근무지 등 사용자가 다양하게 사용할 수 있도록 하기위해 <code>메모</code> 기능을 추가 예정입니다. 따라서 새로운 테이블은 아래와 갖은 구조를 가져야 합니다.</p><p><img src="../../../../images/sqlite3-versioning/2.png" alt=""></p><h2 id="생각만큼-구현이-쉽지-않다"><a href="#생각만큼-구현이-쉽지-않다" class="headerlink" title="생각만큼 구현이 쉽지 않다"></a>생각만큼 구현이 쉽지 않다</h2><p>앱이 실행되고 Database를 관리하는 Singleton의 객체가 초기화 될 때 DB를 초기화하고 Table이 없으면 새로 생성하는 로직은 이미 기존 코드에서 갖고 있습니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sqlite3_exec(db, <span class="string">"CREATE TABLE IF NOT EXISTS WorkingTimes (id INTEGER PRIMARY KEY AUTOINCREMENT, start INTEGER, end INTEGER)"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>) != <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> errmsg = <span class="type">String</span>(cString: sqlite3_errmsg(db)!)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"error creating table: <span class="subst">\(errmsg)</span>"</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Table을 생성하는 SQL문<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> WorkingTimes (<span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT, <span class="keyword">start</span> <span class="built_in">INTEGER</span>, <span class="keyword">end</span> <span class="built_in">INTEGER</span></span><br></pre></td></tr></table></figure></p><p>를 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> WorkingTimes (<span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT, <span class="keyword">start</span> <span class="built_in">INTEGER</span>, <span class="keyword">end</span> <span class="built_in">INTEGER</span>, memo <span class="built_in">TEXT</span></span><br></pre></td></tr></table></figure><p>로 변경하면 쉽게 끝날 것 같지만, 큰 문제가 발생합니다.</p><p>앱을 처음 설치하는 유저의 경우 Table이 정상적으로 생성되고 앱 사용에 문제가 없지만, 기존 v1.6을 사용하던 유저들은 <code>memo</code> Column 이 없는 WorkingTime Table을 사용하게 되므로 UI상에서는 메모를 입력하고 수정하고 저장하지만, 저장도, 불러올 수도 없는 문제가 생깁니다.</p><p>앱 버전관리와 마찬가지로 DB도 버전관리가 필요함을 알 수 있습니다. 앱 버전관리에 대한 필요성은 <a href="http://monibu1548.github.io/2018/05/19/remote-config-forced-update/">iOS 앱 업데이트 (강제 업데이트, 선택 업데이트) 기능 구현 예제</a> 에서 포스팅했습니다.</p><h2 id="SQlite3-스키마-버전관리-방법"><a href="#SQlite3-스키마-버전관리-방법" class="headerlink" title="SQlite3 스키마 버전관리 방법"></a>SQlite3 스키마 버전관리 방법</h2><p>버전관리를 하기 위해서는 3가지를 인지하고 있어야 합니다.</p><ol><li>현재 버전</li><li>최신 버전</li><li>마이그레이션 방법</li></ol><p>따라서 버전관리를 구현함에 있어서 스키마 버전을 관리할 수 있도록 UserDefault를 사용하게 되며 DB 초기화 로직에서 버전에 따라 마이그레이션을 진행하면 됩니다.</p><h3 id="DB-버전-관리"><a href="#DB-버전-관리" class="headerlink" title="DB 버전 관리"></a>DB 버전 관리</h3><p>UserDefaultManager 에 아래 메소드를 추가합니다.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">databaseSchemaVersion</span><span class="params">()</span></span> -&gt; <span class="type">NSInteger</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UserDefaults</span>.standard.integer(forKey: <span class="string">"databaseSchemaVersion"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">setDatabaseSchemaVersion</span><span class="params">(version: NSInteger)</span></span> &#123;</span><br><span class="line">    <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(version, forKey: <span class="string">"databaseSchemaVersion"</span>)</span><br></pre></td></tr></table></figure></p><p>이전 버전에서는 “databaseSchemaVersion” 을 key로 Set된 데이터가 없기 때문에 기존의 스키마를 0으로 사용할 수 있습니다.</p><h3 id="DB-초기화"><a href="#DB-초기화" class="headerlink" title="DB 초기화"></a>DB 초기화</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> databaseSchemaVersion = <span class="type">UserDefaultManager</span>.databaseSchemaVersion()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 생략</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sqlite3_exec(db, <span class="string">"CREATE TABLE IF NOT EXISTS WorkingTimes (id INTEGER PRIMARY KEY AUTOINCREMENT, start INTEGER, end INTEGER, memo TEXT)"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>) != <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> errmsg = <span class="type">String</span>(cString: sqlite3_errmsg(db)!)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"error creating table: <span class="subst">\(errmsg)</span>"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">UserDefaultManager</span>.setDatabaseSchemaVersion(version: <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 생략</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>신규 유저를 위해 WorkingTime Table을 생성하는 Query를 업데이트 하며 정상적으로 Table이 생성되면 UserDefaultManager를 통해 현재 DB Schema 버전을 1로 저장합니다.</p><h3 id="마이그레이션"><a href="#마이그레이션" class="headerlink" title="마이그레이션"></a>마이그레이션</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public func initialize() &#123;</span><br><span class="line">        let databaseSchemaVersion = UserDefaultManager.databaseSchemaVersion()</span><br><span class="line">        </span><br><span class="line">        // ... 생략</span><br><span class="line">        </span><br><span class="line">        if (databaseSchemaVersion == 0) &#123;</span><br><span class="line">            if sqlite3_exec(db, &quot;ALTER TABLE WorkingTimes ADD COLUMN memo TEXT;&quot;, nil, nil, nil) == SQLITE_OK &#123;</span><br><span class="line">                UserDefaultManager.setDatabaseSchemaVersion(version: 1)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>DB초기화 시점에서 현재 SchemaVersion을 확인하여 최신(1)이 아닌 (0)인 경우에 최신버전의 Schema로 맞춰주기 위해 <code>ADD COLUMN</code> Query를 실행합니다. 경우에 따라서는 더 복잡한 코드도 필요할 수 있습니다.</p><h2 id="한계점"><a href="#한계점" class="headerlink" title="한계점"></a>한계점</h2><p>결국 마이그레이션 코드는 레거시로 남게 됩니다. 새로운 스키마가 나올때마다 기존 유저들 대응을 위한 마이그레이션 코드가 지속적으로 추가되어야만 하는 한계가 있습니다.</p><h2 id="한계-대응"><a href="#한계-대응" class="headerlink" title="한계 대응"></a>한계 대응</h2><p>그럼 위에서 설명한 한계를 극복하기 위해서는 어떤 방법이 있을까요. <code>지표 수집</code>을 통해서 현재 사용자들의 어떤 버전의 앱들을 주로 사용하고 있는지 확인하며 사용자가 적은 버전은 강제 업데이트 최소 지원 버전 제한 정책을 통해 제한합니다. 앱 버전을 제한하게 되면 해당 버전에서 사용하던 과거 스키마 버전의 마이그레이션 코드는 지울 수 있게 됩니다.</p>]]></content>
    
    <summary type="html">
    
      Database SQLite3에 스키마 버전관리가 필요한 이유
앱에 신규 기능을 추가하다 보면 Database(SQLite3) 스키마에 변경이 필요한 경우가 생깁니다. 예를 들면, 현재 토이 프로젝트 “퇴근요정” 은 아래와 같은 테이블을 갖고 있습니다.



각 근무시간의 PK인 id, 근무 시작시간 start, 근무 종료시간 end, 이렇게 3개의 column을 갖고 있습니다.

이번 v1.7 에서는 각 근무에 대한 특이사항 및 근무지 등 사용자가 다양하게 사용할 수 있도록 하기위해 메모 기능을 추가 예정입니다. 따라서 새로운 테
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Database" scheme="http://monibu1548.github.io/tags/Database/"/>
    
      <category term="SQLite3" scheme="http://monibu1548.github.io/tags/SQLite3/"/>
    
      <category term="심화" scheme="http://monibu1548.github.io/tags/%EC%8B%AC%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>[iOS] Touch Event가 View를 통해 전달되는 과정 (hitTest)</title>
    <link href="http://monibu1548.github.io/2019/02/09/hittest/"/>
    <id>http://monibu1548.github.io/2019/02/09/hittest/</id>
    <published>2019-02-09T06:09:24.000Z</published>
    <updated>2019-03-31T11:27:51.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hitTest-를-통해-View-계층구조를-따라-Touch가-전달되는-과정을-살펴보자"><a href="#hitTest-를-통해-View-계층구조를-따라-Touch가-전달되는-과정을-살펴보자" class="headerlink" title="hitTest:: 를 통해 View 계층구조를 따라 Touch가 전달되는 과정을 살펴보자"></a>hitTest:: 를 통해 View 계층구조를 따라 Touch가 전달되는 과정을 살펴보자</h1><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>앱을 개발하다보면 복잡한 View Hierachy를 만나게 됩니다. 거기에 Button, tableViewCell, CollectionViewCell 등 UserInteraction을 받는 View들이 겹치게 되면 기대와 달리 터치 이벤트를 받지 못하는 오류를 만날 수 있습니다.<br>이번 포스팅을 통해 iOS에서 Touch 이벤트가 Subview에게 전달되는 과정을 이해함으로써 좀 더 나은 앱을 만들 수 있었으면 합니다.</p><h2 id="사용자-입장에서의-터치-iOS-시스템-입장에서의-터치"><a href="#사용자-입장에서의-터치-iOS-시스템-입장에서의-터치" class="headerlink" title="사용자 입장에서의 터치, iOS 시스템 입장에서의 터치"></a>사용자 입장에서의 터치, iOS 시스템 입장에서의 터치</h2><h3 id="사용자-입장"><a href="#사용자-입장" class="headerlink" title="사용자 입장"></a>사용자 입장</h3><p>당연한 이야기이지만 사용자와 Interaction하는 View(UIButton, UIScrollView 등…)들은 사용자에게 보이기 위해 디바이스 화면상에서 가장 최상단에 위치합니다. 사용자들은 눈에 보이는 Button을 직접 누르고, 스크롤을 직접 내리는 것으로 인식합니다.</p><h3 id="iOS-시스템-입장"><a href="#iOS-시스템-입장" class="headerlink" title="iOS 시스템 입장"></a>iOS 시스템 입장</h3><p>iOS 시스템은 사용자의 입장과 반대로 동작합니다. 사용자의 터치는 iOS 시스템이 입력받아 UIApplicaion 에게 전달, UIWindow를 통해 View Hierachy를 따라 Top-down으로 전달됩니다. 따라서 View의 Insteraction을 개발할 때는 iOS 시스템 입장에서 접근해야합니다.</p><h2 id="HitTest"><a href="#HitTest" class="headerlink" title="HitTest::"></a>HitTest::</h2><p>UIView에는 HitTest:: 라는 함수가 있습니다. 이 함수를 통해 최종적으로 어떤 View가 사용자의 이벤트를 처리할 지 결정합니다. 이 과정을 이해하면 오류 수정 및 커스텀 뷰 개발을 더 잘 할 수 있습니다!</p><h3 id="직접-테스트해보자"><a href="#직접-테스트해보자" class="headerlink" title="직접 테스트해보자"></a>직접 테스트해보자</h3><p>아래의 그림처럼 View Hierachy를 만든 후 각 번호의 위치를 클릭하여 최종적으로 사용자 이벤트를 처리하는 View를 찾아보겠습니다.</p><p><img src="../../../../images/hittest/1.png" alt=""></p><ul><li><code>1</code>번 위치 클릭 : View1</li><li><code>2</code>번 위치 클릭 : View2</li><li><code>3</code>번 위치 클릭 : nil<ul><li>View2는 View1의 SubView이지만 3번 위치는 View1의 외부에 존재합니다. 따라서 View1, View2 모두 이벤트를 받지 못해 nil이 리턴됩니다.</li></ul></li><li><code>4</code>번 위치 클릭 : View5</li><li><code>5</code>번 위치 클릭 : View1<ul><li>View3은 userInteractionEnabled 옵션을 NO로 지정했습니다. 따라서 interaction을 받지도, subview로 전달하지도 못하고 최종적으로 View1이 리턴됩니다.</li></ul></li><li><code>6</code>번 위치 클릭 : View4<ul><li>View4는 View3위에 있는것처럼 보이지만 View Hierachy로 보면 View1의 Subview입니다. View3과는 무관하게 hitTest에 통과하여 View4를 리턴합니다.</li></ul></li><li><code>7</code>번 위치 클릭 : View4</li><li><code>8</code>번 위치 클릭 : View1<ul><li>View6은 UserInteraction을 받지 못하는 View3의 Subview입니다. 최종적으로 hitTest를 통과한 View1이 리턴됩니다.</li></ul></li></ul><h2 id="hitTest-View-Hierachy-순회-순서"><a href="#hitTest-View-Hierachy-순회-순서" class="headerlink" title="hitTest View Hierachy 순회 순서"></a>hitTest View Hierachy 순회 순서</h2><p>DFS방식으로 순회합니다. 가장 최 상단의 View1을 먼저 순회합니다.<br>View2, View3, View4는 동일 계층입니다. 동일 계층에서는 index가 큰 순서부터 순회합니다. (화면 상에서 가장 가까이 보이는 순서)<br>순회 도중 Subview를 소유하고 있다면 Subview의 hitTest를 진행합니다.</p><h2 id="HitTest-에-통과하는-Touch-를-받는-조건"><a href="#HitTest-에-통과하는-Touch-를-받는-조건" class="headerlink" title="HitTest:: 에 통과하는 (Touch 를 받는) 조건"></a>HitTest:: 에 통과하는 (Touch 를 받는) 조건</h2><ol><li>Hidden = NO</li><li>Alpha &gt; 0.01</li><li>userInteractionEnabled = YES</li></ol>]]></content>
    
    <summary type="html">
    
      hitTest:: 를 통해 View 계층구조를 따라 Touch가 전달되는 과정을 살펴보자
서론
앱을 개발하다보면 복잡한 View Hierachy를 만나게 됩니다. 거기에 Button, tableViewCell, CollectionViewCell 등 UserInteraction을 받는 View들이 겹치게 되면 기대와 달리 터치 이벤트를 받지 못하는 오류를 만날 수 있습니다.
이번 포스팅을 통해 iOS에서 Touch 이벤트가 Subview에게 전달되는 과정을 이해함으로써 좀 더 나은 앱을 만들 수 있었으면 합니다.

사용자 입장에서의 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="심화" scheme="http://monibu1548.github.io/tags/%EC%8B%AC%ED%99%94/"/>
    
      <category term="HitTest" scheme="http://monibu1548.github.io/tags/HitTest/"/>
    
  </entry>
  
  <entry>
    <title>iOS의 View, ViewController Layout Cycle</title>
    <link href="http://monibu1548.github.io/2019/02/08/layout-cycle/"/>
    <id>http://monibu1548.github.io/2019/02/08/layout-cycle/</id>
    <published>2019-02-08T13:43:08.000Z</published>
    <updated>2019-02-08T14:51:57.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View-ViewController-Layout-Cycle"><a href="#View-ViewController-Layout-Cycle" class="headerlink" title="View(ViewController) Layout Cycle"></a>View(ViewController) Layout Cycle</h1><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>앱개발의 40% 정도는 View를 그리고 Layout을 구성하는데 있다고 생각합니다. 어떤 앱은 Frame기반 Layout을 사용하며 또 어떤 앱은 AutoLayout기반의 Layout을 이용합니다.<br>iOS11과 iPhoneX의 등장으로 사실상 AutoLayout은 선택이 아닌 필수가 되었습니다.<br>iPhoneX시리즈의 노치디자인에 대응하기 위해서는 Frame기반보다 AutoLayout기반이 더 효율적이기 때문입니다.<br>하지만 현실적으로 기존 Frame기반의 레이아웃을 한번에 AutoLayout으로 변경하기 어렵기 때문에 두 가지 방식을 섞어 사용하게 되는데, 여기에서 View(ViewController)의 Layout Cycle을 이해할 필요가 있습니다.<br>이번 포스팅에서는 Layout Cycle의 이해를 통해 좀 더 나은 앱을 만들수 있는 공부를 목적으로 합니다.</p><h2 id="View를-그리는-3단계-프로세스"><a href="#View를-그리는-3단계-프로세스" class="headerlink" title="View를 그리는 3단계 프로세스"></a>View를 그리는 3단계 프로세스</h2><p><img src="../../../../images/layout-cycle/1.png" alt=""></p><ol><li>Constraint Update</li></ol><ul><li>제약조건(Constraint)를 업데이트 합니다. Constraint는 Code로도 구성 가능하며 대부분 Interface Builder를 이용해 Constraint를 만듭니다. Constraint는 말 그대로 제약조건이며 View를 실제로 배치하는데에는 영향을 주지 않습니다. 특정 조건에 따라 Constraint를 갱신하여 Dynamic View를 구성할 수 있습니다.</li><li>Constraint의 업데이트 순서는 View 계층구조에서 가장 하위뷰부터 상위뷰로 올라갑니다.</li></ul><ol start="2"><li>Layout Update</li></ol><ul><li>Layout을 업데이트 합니다. 여기에서 Layout이란 구체적인 뷰의 Frame 수치 값입니다. Constraint 값을 이용해 View가 위치해야 할 수치값을 갱신합니다.</li><li>layout의 업데이트 순서는 View의 계층구조에서 가장 상위뷰부터 하위뷰로 내려갑니다.</li></ul><ol start="3"><li>Render</li></ol><ul><li>View를 2단계에서 구한 수치값을 이용해 화면에 직접 그립니다. UIView의 DrawRect: 메소드가 이에 해당합니다.</li></ul><h2 id="ViewController의-Layout-Cycle"><a href="#ViewController의-Layout-Cycle" class="headerlink" title="ViewController의 Layout Cycle"></a>ViewController의 Layout Cycle</h2><p>전 단계에서 이해한 3단계 프로세스를 기반으로 ViewController의 Layout Cycle을 보면 다음과 같습니다.<br><img src="../../../../images/layout-cycle/2.png" alt=""></p><p>ViewController는 소유하고 있는 View들의 Constraint, Layout, Render 순서에 따라 Override 메소드들을 시스템의 호출에 의해 실행합니다.</p><h2 id="위치-변경-등으로-View를-다시-그려야-할-때-개발자가-해야-하는-것"><a href="#위치-변경-등으로-View를-다시-그려야-할-때-개발자가-해야-하는-것" class="headerlink" title="위치 변경 등으로 View를 다시 그려야 할 때 개발자가 해야 하는 것"></a>위치 변경 등으로 View를 다시 그려야 할 때 개발자가 해야 하는 것</h2><ul><li>Layout을 갱신할 때 : setNeedsLayout() 함수 호출로 View에 layout을 갱신해야 한다는 플래그를 표시한다. 시스템이 플래그를 보고 ViewController의 Layout Update 프로세스를 실행시킨다.</li><li>Constraint를 갱신할 때 : setNeedsUpdateConstraints() 함수 호출로 View에 constraint를 갱신해야 한다는 플래그를 표시한다. 시스템이 플래그를 보고 ViewController의 Constraint Update 프로세스를 실행시킨다.</li></ul><h2 id="플래그를-표시한다는-의미"><a href="#플래그를-표시한다는-의미" class="headerlink" title="플래그를 표시한다는 의미"></a>플래그를 표시한다는 의미</h2><ul><li>시스템은 개발자가 setNeedsLayout() 또는 setNeedsUpdateConstraints()를 호출하면 바로 View를 다시 그리지 않는다. 한번의 RunLoop 안에서 View의 갱신이 여러번 일어나면 비효율 적이기 때문에, 가장 효율적인 방법을 고려했다.</li><li>iOS는 RunLoop가 끝나고 다음 RunLoop를 실행할 때 view의 플래그를 보고 한번에 모든 View를 갱신하는 방법을 선택했다.</li></ul><h2 id="개발자가-플래그를-표시하지-않으면-View는-갱신되지-않을까"><a href="#개발자가-플래그를-표시하지-않으면-View는-갱신되지-않을까" class="headerlink" title="개발자가 플래그를 표시하지 않으면 View는 갱신되지 않을까?"></a>개발자가 플래그를 표시하지 않으면 View는 갱신되지 않을까?</h2><p>개발자가 View에 갱신 플래그를 심는것은 옵션, 시스템적으로 플래그를 표시하는 케이스가 있다.</p><ul><li>View의 Frame 변경.</li><li>View에 subView가 추가되는 경우.</li><li>디바이스의 orientation이 변경되는 경우.(디바이스 회전)</li><li>Constraint Constant의 변경.</li></ul><p>등이 있으며. 이 경우에도 View는 다음 RunLoop에서 갱신된다.</p><h2 id="LayoutlayoutIfNeeded-updateConstraintsIfNeeded-의-용도"><a href="#LayoutlayoutIfNeeded-updateConstraintsIfNeeded-의-용도" class="headerlink" title="LayoutlayoutIfNeeded(), updateConstraintsIfNeeded()의 용도"></a>LayoutlayoutIfNeeded(), updateConstraintsIfNeeded()의 용도</h2><p>위 단계에서 플래그를 통해 다음 RunLoop에서 View를 갱신될 수 있도록 하는 방법을 알았습니다.<br>UIView의 메소드를 더 살펴보면 LayoutlayoutIfNeeded(), updateConstraintsIfNeeded()가 있습니다.<br>이 메소드는 다음 RunLoop가 아닌, 호출 그 즉시 View를 갱신합니다. 시스템이 호출을 기다리지 않고 바로 호출하는 경우는 Animation입니다.<br>UIView의 애니메이션은 View의 시작시점, View의 갱신 종료 시점 두가지 End point를 자연스럽게 연결시켜주는 동작이기 때문에 View를 바로 갱신시켜줘야 하며 그 이유로 위 메소드를 사용합니다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>앱을 구현하면서 Server API의 플래그 등 다양한 경우에 Dynamic View를 구현해야 합니다. Layout Cycle을 정확하게 이해하고 적절한 메소드에 로직을 구현함으로써 사이드 이펙트 없는 View를 그릴 수 있도록 계에에속 연습해야겠습니다.<br><del>그럼에도 불구하고 왜 iOS10 에서는 AutoLayout이 비정상적으로 동작하는 경우가 많을까요 ㅠㅜ</del></p>]]></content>
    
    <summary type="html">
    
      View(ViewController) Layout Cycle
서론
앱개발의 40% 정도는 View를 그리고 Layout을 구성하는데 있다고 생각합니다. 어떤 앱은 Frame기반 Layout을 사용하며 또 어떤 앱은 AutoLayout기반의 Layout을 이용합니다.
iOS11과 iPhoneX의 등장으로 사실상 AutoLayout은 선택이 아닌 필수가 되었습니다.
iPhoneX시리즈의 노치디자인에 대응하기 위해서는 Frame기반보다 AutoLayout기반이 더 효율적이기 때문입니다.
하지만 현실적으로 기존 Frame기반의 레이아웃을 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="심화" scheme="http://monibu1548.github.io/tags/%EC%8B%AC%ED%99%94/"/>
    
      <category term="AutoLayout" scheme="http://monibu1548.github.io/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>[띵킹노트] MVVM패턴을 공부하면서, 기존 MVC패턴의 프로젝트와 비교</title>
    <link href="http://monibu1548.github.io/2019/01/26/dev-2019-01-26/"/>
    <id>http://monibu1548.github.io/2019/01/26/dev-2019-01-26/</id>
    <published>2019-01-26T14:16:28.000Z</published>
    <updated>2019-01-26T14:18:27.635Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/dev/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../../images/dev/3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="띵킹노트" scheme="http://monibu1548.github.io/categories/%EB%9D%B5%ED%82%B9%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="띵킹노트" scheme="http://monibu1548.github.io/tags/%EB%9D%B5%ED%82%B9%EB%85%B8%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>[띵킹노트] Firebase Auth &lt;=&gt; DB 연동에 대한 고민</title>
    <link href="http://monibu1548.github.io/2019/01/20/dev-2019-01-20/"/>
    <id>http://monibu1548.github.io/2019/01/20/dev-2019-01-20/</id>
    <published>2019-01-20T14:26:43.000Z</published>
    <updated>2019-01-20T14:30:59.552Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../images/dev/1.png" alt=""></p><p><img src="../../../../images/dev/2.png" alt=""></p><ul><li>100% 백앤드 없이 서비스 하나 만들기는 어려워 보인다. 아무리 Firebase 라도..</li><li>현재 선택지는 2가지, Firebase Cloud Function을 이용하거나 NodeJS 하나 호스팅하거나. 갑자기 스케일이 매우 커진다.</li></ul>]]></content>
    
    <summary type="html">
    
      * 100% 백앤드 없이 서비스 하나 만들기는 어려워 보인다. 아무리 Firebase 라도..
 * 현재 선택지는 2가지, Firebase Cloud Function을 이용하거나 NodeJS 하나 호스팅하거나. 갑자기 스케일이 매우 커진다.
    
    </summary>
    
      <category term="띵킹노트" scheme="http://monibu1548.github.io/categories/%EB%9D%B5%ED%82%B9%EB%85%B8%ED%8A%B8/"/>
    
    
      <category term="띵킹노트" scheme="http://monibu1548.github.io/tags/%EB%9D%B5%ED%82%B9%EB%85%B8%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS앱 고도화 - Firebase Authentication 적용하기 첫번째 (이메일/비밀번호 회원가입, 로그인)</title>
    <link href="http://monibu1548.github.io/2019/01/13/firebase-auth-1/"/>
    <id>http://monibu1548.github.io/2019/01/13/firebase-auth-1/</id>
    <published>2019-01-13T13:15:25.767Z</published>
    <updated>2019-01-20T04:09:13.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS앱-고도화-Firebase-Authentication-적용하기-첫번째-이메일-비밀번호-회원가입-로그인"><a href="#iOS앱-고도화-Firebase-Authentication-적용하기-첫번째-이메일-비밀번호-회원가입-로그인" class="headerlink" title="iOS앱 고도화 - Firebase Authentication 적용하기 첫번째 (이메일/비밀번호 회원가입, 로그인)"></a>iOS앱 고도화 - Firebase Authentication 적용하기 첫번째 (이메일/비밀번호 회원가입, 로그인)</h1><p>이 포스트를 시작으로 지금까지 개발했던 앱에 Firebase Authentication을 적용합니다.<br>로그인 (인증)을 적용하는 이유는 다음과 같습니다.</p><ol><li>유저 정보 획득 (Push Target을 디테일하게 설정, 유저 유입/이탈 확인)</li><li>Sqlite3에 저장하던 정보를 Firebase Realtime DB로 마이그레이션 할 수 있음. =&gt; 위젯 개발 가능</li><li>나중에 게시판, 채팅 구현에 있어서 로그인 기반이 자리잡혀 있어야 함.</li></ol><h2 id="Firebase-Authentication-Console-설정"><a href="#Firebase-Authentication-Console-설정" class="headerlink" title="Firebase Authentication Console 설정"></a>Firebase Authentication Console 설정</h2><ol><li>Firebase Authentication Console 페이지 열기</li></ol><p><img src="../../../../images/firebase-auth/1.png" alt=""></p><ul><li>Firebase Console &gt; Authentication &gt; 로그인 방법 설정</li></ul><ol start="2"><li>로그인 제공업체 설정</li></ol><p><img src="../../../../images/firebase-auth/2.png" alt=""></p><ul><li>2019년 1월 현재 기준으로 이메일, 전화 구글, 등 9가지의 로그인 방법을 제시하고 있습니다.</li><li>퇴근요정 앱에는 <code>익명</code>과 <code>이메일</code>로그인을 사용할 예정입니다.</li></ul><h2 id="iOS-앱-구현-이메일-비밀번호-회원가입"><a href="#iOS-앱-구현-이메일-비밀번호-회원가입" class="headerlink" title="iOS 앱 구현 (이메일/비밀번호 회원가입)"></a>iOS 앱 구현 (이메일/비밀번호 회원가입)</h2><ol><li>Pod install</li></ol><p>프로젝트의 Podfile에 <code>Firebase/Auth</code>를 추가하고 pod install을 실행합니다.</p><ol start="2"><li>Firebase 초기화</li></ol><p>AppDelegate의 application:didFinishLaunchingWithOptions: 메소드에서 FirebaseApp 객체를 초기화합니다.<br>기존에 Firebase를 사용하고 있었다면 이미 초기화 하고 있습니다.</p><ol start="3"><li>로그인 페이지 제작</li></ol><p><img src="../../../../images/firebase-auth/5.png" alt=""></p><p>위 처럼 로그인 페이지를 만들어줍니다. 디자인은…. 나중에 :)<br>그리고 이제 앱의 첫 실행페이지를 로그인 페이지로 연결해 줍니다.</p><p><img src="../../../../images/firebase-auth/6.png" alt=""></p><p>가장 첫번째로 필요한 페이지. 로그인을 하기 전 회원가입을 먼저 해야합니다. 이메일 로그인 페이지를 구현합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> FirebaseAuth</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailSignUpViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> emailTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">didSignUpButtonTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> email = emailTextField.text, <span class="keyword">let</span> password = passwordTextField.text <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Auth</span>.auth().createUser(withEmail: email, password: password) &#123; (authResult, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> user = authResult?.user <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 회원가입 정상 처리 후 다음 로직, 로그인 페이지 or 바로 로그인 시키기</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 회원가입 실패</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 구성 후 회원가입을 시도하면 다음과 같은 결과가 리턴됩니다.</p><p><img src="../../../../images/firebase-auth/7.png" alt=""></p><p>AuthToken값이 담긴 FIRUser 객체가 리턴되며 Firebase Authentication console에서 회원가입이 되었음을 확인할 수 있습니다.</p><p><img src="../../../../images/firebase-auth/8.png" alt=""></p><h2 id="iOS-앱-구현-이메일-비밀번호-로그인"><a href="#iOS-앱-구현-이메일-비밀번호-로그인" class="headerlink" title="iOS 앱 구현 (이메일/비밀번호 로그인)"></a>iOS 앱 구현 (이메일/비밀번호 로그인)</h2><p><img src="../../../../images/firebase-auth/9.png" alt=""></p><p>이메일/비밀번호 로그인 페이지의 구현.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> FirebaseAuth</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailLoginViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> emailTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>!</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">didLoginButtonTapped</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> email = emailTextField.text, <span class="keyword">let</span> password = passwordTextField.text <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Auth</span>.auth().signIn(withEmail: email, password: password) &#123; (user, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 로그인 성공 user 객체에서 정보 사용</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 로그인 실패 처리</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>로그인 성공 처리</p><p><img src="../../../../images/firebase-auth/10.png" alt=""></p><h2 id="로그인-성공-이후-처리과정에-대해서"><a href="#로그인-성공-이후-처리과정에-대해서" class="headerlink" title="로그인 성공 이후 처리과정에 대해서.."></a>로그인 성공 이후 처리과정에 대해서..</h2><p>로그인 이후에는 uid를 key값으로 DB에 데이터를 읽고/쓰며 사용자에 특화된 서비스를 제공할 수 있습니다.<br>uid의 관리 (세션 유지, 로그아웃) 등의 처리는 주로 LoginManager 또는 SessionManager라는 이름의 싱글톤객체를 통해 앱의 라이프사이클 내에서 사용하도록 합니다.</p><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p>지금까지 세션관리는 까다로운 영역이었다. 학부시절 nodejs passport로 로그인을 관리하던 때, 신입교육때 spring에서 redis를 이용해 세션을 관리 때문에 머리아팠던 적이 있다.<br>퇴근요정 앱에 로그인 관련 기능을 추가하기로 마음먹으면서 고생 꽤나 먹겠구나 싶었다.</p><p>하.지.만 역시 Firebase… 회원DB 는 생각할 필요도 없으며 클라이언트 단에서도 API구현의 복잡성 없이 제공되는 API 호출만으로 accessToken까지 구하는데 막힘 없이 간단하게 성공했다.</p><p>일단 email 인증으로 시작했지만, 하나 하나 더 붙여나가 볼 예정.</p>]]></content>
    
    <summary type="html">
    
      iOS앱 고도화 - Firebase Authentication 적용하기 첫번째 (이메일/비밀번호 회원가입, 로그인)
이 포스트를 시작으로 지금까지 개발했던 앱에 Firebase Authentication을 적용합니다.
로그인 (인증)을 적용하는 이유는 다음과 같습니다.

 1. 유저 정보 획득 (Push Target을 디테일하게 설정, 유저 유입/이탈 확인)
 2. Sqlite3에 저장하던 정보를 Firebase Realtime DB로 마이그레이션 할 수 있음. =&gt; 위젯 개발 가능
 3. 나중에 게시판, 채팅 구현에 있어서 로그인
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/categories/iOS/Firebase/"/>
    
    
  </entry>
  
  <entry>
    <title>XCode Server Bot 백업 작업 (XCode Server Backup strategy)</title>
    <link href="http://monibu1548.github.io/2019/01/09/xcode-server-backup/"/>
    <id>http://monibu1548.github.io/2019/01/09/xcode-server-backup/</id>
    <published>2019-01-09T13:16:58.000Z</published>
    <updated>2019-01-20T04:11:16.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="본문-읽기-전-3줄요약"><a href="#본문-읽기-전-3줄요약" class="headerlink" title="본문 읽기 전 3줄요약"></a>본문 읽기 전 3줄요약</h2><ul><li><code>GET</code> https://{xcode server ip}:20343/api/bots : Bots 정보 백업</li><li><code>POST</code> 메소드로 Bot 등록할 수 있도록 XCode Server 변형</li><li><code>POST</code> https://{xcode server ip}:20343/api/bots/noauth : 백업한 정보를 이용해 등록</li></ul><h2 id="XCode-Server-Backup-전략"><a href="#XCode-Server-Backup-전략" class="headerlink" title="XCode Server Backup 전략"></a>XCode Server Backup 전략</h2><p>이전 포스팅을 통해 XCode Server로 Bot을 만들어 쉽게 archive하고 ipa를 export 하는 과정을 자동화 했습니다.<br><a href="http://monibu1548.github.io/2018/04/25/xcode-server-intro/">XCode Server를 이용한 CI(continuous integration)</a></p><p>프로젝트 진행 중에 빌드머신이 고장 또는 성능향상을 이유로 새로운 빌드머신으로 교체를 할 때, 어떻게 Bots을 쉽게 이전할 수 있을까요?<br>이 포스팅에서는 Bots의 백업, 다른 빌드머신으로의 이전 과정을 다룹니다.</p><p>Apple 가이드 문서, StackOverflow에도 공식적인 백업방법은 언급되어 있지 않습니다.<br>제가 제시하는 방법은 비공식적으로 XCode Server API를 우회하여 백업, 이전하는 방법으로 XCode Server의 버전 등에 따라 일부 다를 수 있습니다.</p><h2 id="XCode-Server에-대한-이해"><a href="#XCode-Server에-대한-이해" class="headerlink" title="XCode Server에 대한 이해"></a>XCode Server에 대한 이해</h2><p>우선, XCode Server의 구조에 대해 알아봅니다. XCode Server는 내부적으로 apache, nodejs, redis, couchDB로 구성되어 있습니다.<br>여기서 눈여겨 봐야할 부분은 nodejs 입니다.</p><p>XCode에서 Bot을 만들고 Integration을 실행시키고 하는 과정을 XCode Server의 API를 호출하는 과정이며, 이 API는 NodeJS가 처리합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Developer/XcodeServer/CurrentXcodeSymlink/Contents/Developer/usr/share/xcs</span><br></pre></td></tr></table></figure><p>위 경로는 XCode Server가 설치되어 있는 위치이며 여기에서 XCode Server의 코드를 볼 수 있습니다.</p><p><img src="../../../../images/xcode-server-backup/1.png" alt=""></p><h2 id="XCode-Server에서-제공하는-API"><a href="#XCode-Server에서-제공하는-API" class="headerlink" title="XCode Server에서 제공하는 API"></a>XCode Server에서 제공하는 API</h2><p>XCode Server에서 제공하는 API를 통해 raw한 데이터를 직접 볼 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://&#123;xcode server ip&#125;:20343/api/xcodes</span><br></pre></td></tr></table></figure><ul><li>XCode Server의 XCode 정보를 조회하는 API</li></ul><p>하나의 예로 위의 API를 호출하면 다음과 같은 결과가 내려옵니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">count: 1,</span><br><span class="line">results: [</span><br><span class="line">&#123;</span><br><span class="line">_id: "c67d878dbc911a8f84ea65393e000e99",</span><br><span class="line">_rev: "3-31c9c9d424fb7221fafbf68f434b8cf2",</span><br><span class="line">path: "/Applications/Xcode.app",</span><br><span class="line">buildNumber: "10A255",</span><br><span class="line">primary: true,</span><br><span class="line">version: "10.0",</span><br><span class="line">agentID: "6e3b6b1cef06fb79387f04391c001d03",</span><br><span class="line">doc_type: "xcode",</span><br><span class="line">tinyID: "CAE0F35"</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 외 XCode Server API는 <a href="https://developer.apple.com/library/archive/documentation/Xcode/Conceptual/XcodeServerAPIReference/index.html" target="_blank" rel="noopener">Apple XCode Server API문서</a>에서 확인할 수 있습니다.</p><p><code>네 문서 성의 없습니다. 없는 API도 있고, 제대로 동작 하지 않는 API도 많습니다. Bot에 관련된 API들이 그렇죠.. 정말 이걸 쓰라고 만든건지..</code></p><h2 id="XCode-Server에-등록된-Bot-들의-정보-백업하기"><a href="#XCode-Server에-등록된-Bot-들의-정보-백업하기" class="headerlink" title="XCode Server에 등록된 Bot 들의 정보 백업하기"></a>XCode Server에 등록된 Bot 들의 정보 백업하기</h2><p>XCode Server Bot의 백업도 같은 방법을 사용합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://&#123;xcode server ip&#125;:20343/api/bots</span><br></pre></td></tr></table></figure><ul><li>response</li></ul><p><img src="../../../../images/xcode-server-backup/2.png" alt=""></p><p>브라우저에서 위 주소에 접근하면 Bot에 대한 정보를 볼 수 있습니다.<br>이 텍스트를 <code>저장</code> 하시면 됩니다.</p><p>이 정보를 이용해 다른 빌드머신에 동일한 Bot을 생성할 겁니다.</p><h2 id="XCode-Server에-백업한-Bot-재등록하기"><a href="#XCode-Server에-백업한-Bot-재등록하기" class="headerlink" title="XCode Server에 백업한 Bot 재등록하기"></a>XCode Server에 백업한 Bot 재등록하기</h2><p>브라우저를 통해 /api/bots의 주소에 GET 메소드로 request를 날리면 bots들의 정보를 읽어옵니다.<br>그렇다면 반대로 /api/bots의 주소에 POST 메소드로 request를 날리면?</p><p><code>네, 안됩니다</code></p><ul><li>삽질하면서 가장 어이없던 부분인데요, XCode Server API 공식 가이드 문서가 잘못되어 있으며, 인증 이유로도 호출이 되지 않습니다.</li></ul><h2 id="XCode-Server에-커스텀-route-등록하기"><a href="#XCode-Server에-커스텀-route-등록하기" class="headerlink" title="XCode Server에 커스텀 route 등록하기"></a>XCode Server에 커스텀 route 등록하기</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Developer/XcodeServer/CurrentXcodeSymlink/Contents/Developer/usr/share/xcs/xcsd/routes/routes_bot.js</span><br></pre></td></tr></table></figure><p>vim 또는 텍스트에디터로 위 파일을 열어줍니다. (관리자 권한으로 열어야 수정 가능합니다.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line">    auth = <span class="built_in">require</span>(<span class="string">'../classes/authClass.js'</span>),</span><br><span class="line">    bot = <span class="built_in">require</span>(<span class="string">'../classes/botClass.js'</span>),</span><br><span class="line">    routes_utils = <span class="built_in">require</span>(<span class="string">'./routes_utils.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prepareRequest = routes_utils.prepareRequest,</span><br><span class="line">    setTTLInDocumentIfNeeded = routes_utils.setTTLInDocumentIfNeeded,</span><br><span class="line">    enforceBotCreatorRole = auth.enforceBotCreatorRole,</span><br><span class="line">    enforceBotViewerRole = auth.enforceBotViewerRole;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.route(<span class="string">'/bots/:id'</span>)</span><br><span class="line">    .get(prepareRequest, enforceBotViewerRole, bot.findBot)</span><br><span class="line">    .patch(prepareRequest, enforceBotCreatorRole, bot.update);</span><br><span class="line"></span><br><span class="line">router.delete(<span class="string">'/bots/:id/:rev?'</span>, prepareRequest, enforceBotCreatorRole, bot.remove);</span><br><span class="line"></span><br><span class="line">router.route(<span class="string">'/bots'</span>)</span><br><span class="line">    .get(prepareRequest, enforceBotViewerRole, bot.list)</span><br><span class="line">    .post(prepareRequest, enforceBotCreatorRole, setTTLInDocumentIfNeeded, bot.create);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/bots/:id/duplicate'</span>, prepareRequest, enforceBotCreatorRole, bot.duplicate);</span><br><span class="line">router.get(<span class="string">'/bots/:id/stats'</span>, prepareRequest, enforceBotViewerRole, bot.stats);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>NodeJS 코드입니다. NodeJS를 몰라도 어느정도 해석할 수 있습니다.<br>주의깊게 볼 부분은 21 ~ 23 라인입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.route(<span class="string">'/bots'</span>)</span><br><span class="line">    .get(prepareRequest, enforceBotViewerRole, bot.list)</span><br><span class="line">    .post(prepareRequest, enforceBotCreatorRole, setTTLInDocumentIfNeeded, bot.create);</span><br></pre></td></tr></table></figure><p>/bots 에 GET으로 request를 보내면 bot.list를 리턴해주며<br>/bots 에 POST로 request를 보내면 bot을 create 한다는 내용을 유추할 수 있습니다. 다만 중간에 setTTLInDocumentIfNeeded 파라미터를 통해 인증이 필요하다는 내용도 알 수 있습니다.</p><p>그 아래 다음 라인을 추가하여 인증 없이 bot을 만들 수 있는 route를 열어줍니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.route(<span class="string">'/bots/noauth'</span>)</span><br><span class="line">    .post(prepareRequest, bot.create);</span><br></pre></td></tr></table></figure><p>저장 후 XCode Server를 재실행시킵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo xcscontrol --shutdown</span><br><span class="line">sudo xcscontrol --start</span><br></pre></td></tr></table></figure><h2 id="Postman을-이용해-POST-request-보내기"><a href="#Postman을-이용해-POST-request-보내기" class="headerlink" title="Postman을 이용해 POST request 보내기"></a>Postman을 이용해 POST request 보내기</h2><p>이제 백업했던 Bots 정보를 POST로 등록할 순서입니다.</p><ol><li>먼저 https로 요청을 보내기 때문에, postman에서 한가지 옵션을 설정해야 합니다. Settings &gt; General 에서 SSL certificate verification 옵션을 OFF로 설정합니다.</li></ol><p><img src="../../../../images/xcode-server-backup/3.png" alt=""></p><ol start="2"><li>Header에서 Content-Type 을 application/json 으로 설정합니다.</li></ol><p><img src="../../../../images/xcode-server-backup/4.png" alt=""></p><p>Body &gt; raw 에서 백업받은 Bot 하나를 입력합니다.<br><code>다수의 봇을 동시에 등록은 불가능 합니다, 1번에 1개의 봇의 정보를 입력합니다.</code></p><ul><li><code>Bot 1개의 정보란</code>?<br><img src="../../../../images/xcode-server-backup/5.png" alt=""></li></ul><p>api/bots 에서 가져온 봇의 정보를 <a href="https://jsoneditoronline.org/" target="_blank" rel="noopener">https://jsoneditoronline.org/</a> 에 넣으면 json의 형태로 쉽게 구조화 할 수 있는데요,<br>여기서 우측 result 배열의 요소가 각 bot에 해당합니다.</p><p>Bot 하나만 가져오면 이렇게 생겼습니다.<br><img src="../../../../images/xcode-server-backup/6.png" alt=""></p><ol start="3"><li><p>이제 Send를 눌러 밀어 넣습니다.<br><img src="../../../../images/xcode-server-backup/7.png" alt=""></p></li><li><p>다음과 같은 결과가 나오면 성공!<br><img src="../../../../images/xcode-server-backup/8.png" alt=""></p></li></ol><p>response code가 201로 떨어지며, response body는 request body가 동일하게 내려옵니다.</p><p>이제 XCode를 켜고 XCode Server에 연결하면 추가된 Bot을 볼 수 있습니다.</p><h1 id="끝"><a href="#끝" class="headerlink" title="끝."></a>끝.</h1>]]></content>
    
    <summary type="html">
    
      본문 읽기 전 3줄요약
 * GET https://{xcode server ip}:20343/api/bots : Bots 정보 백업
 * POST 메소드로 Bot 등록할 수 있도록 XCode Server 변형
 * POST https://{xcode server ip}:20343/api/bots/noauth : 백업한 정보를 이용해 등록

XCode Server Backup 전략
이전 포스팅을 통해 XCode Server로 Bot을 만들어 쉽게 archive하고 ipa를 export 하는 과정을 자동화 했습니다.
XCode Serv
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="XCodeServer" scheme="http://monibu1548.github.io/categories/iOS/XCodeServer/"/>
    
    
      <category term="XCodeServer" scheme="http://monibu1548.github.io/tags/XCodeServer/"/>
    
      <category term="XCode" scheme="http://monibu1548.github.io/tags/XCode/"/>
    
      <category term="생산성" scheme="http://monibu1548.github.io/tags/%EC%83%9D%EC%82%B0%EC%84%B1/"/>
    
  </entry>
  
  <entry>
    <title>[RxSwift] 3일차, RxSwift Operator</title>
    <link href="http://monibu1548.github.io/2018/10/23/rxswift-operator/"/>
    <id>http://monibu1548.github.io/2018/10/23/rxswift-operator/</id>
    <published>2018-10-23T14:25:11.000Z</published>
    <updated>2018-10-23T14:26:00.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h1><p>Operator는 Observable 객체를 구독할 때 넘어오는 event를 Filtering, Transforming, Combining 하기 위해 사용한다.<br>Observable을 구독할 때 event의 element를 그대로 사용할 수 없는 경우, 서비스에서 사용 가능한 객체로 변환하는 과정을 담당한다.</p><h3 id="RxSwift에서는-구현에-필요한-다양한-개념들을-Operator로-미리-구현해-놓았으며-상황에-따라-적절한-Operator를-선택해-사용해야-한다"><a href="#RxSwift에서는-구현에-필요한-다양한-개념들을-Operator로-미리-구현해-놓았으며-상황에-따라-적절한-Operator를-선택해-사용해야-한다" class="headerlink" title="RxSwift에서는 구현에 필요한 다양한 개념들을 Operator로 미리 구현해 놓았으며 상황에 따라 적절한 Operator를 선택해 사용해야 한다."></a>RxSwift에서는 구현에 필요한 다양한 개념들을 Operator로 미리 구현해 놓았으며 상황에 따라 적절한 Operator를 선택해 사용해야 한다.</h3><p>너무 많아서 모두 예제로 만들기에는 너무 많아서 목록만 나열합니다..<br>메소드 이름만 익숙해지는 것도 큰 도움이라고 생각됩니다.</p><p>각 메소드들의 이해는 아래 링크에서 쉽게 시각적으로 배울 수 있습니다.</p><p><a href="http://rxmarbles.com/#ignoreElements" target="_blank" rel="noopener">http://rxmarbles.com/#ignoreElements</a></p><p>RxJS에 대한 내용이지만 기본적으로 Rx에 대한 내용을 다루기 때문에 대부분의 메소드 이름이 같고 내용이 같습니다.</p><h2 id="Filtering-Operators"><a href="#Filtering-Operators" class="headerlink" title="Filtering Operators"></a>Filtering Operators</h2><p>특정 조건에 따라 event를 걸러내는 Operator</p><ul><li>ignoreElements()</li><li>elementAt()</li><li>filter()</li><li>skip()</li><li>skipWhile()</li><li>skipUntil()</li><li>take()</li><li>takeWhile()</li><li>takeUntil()</li><li>distinctUtilChanged()</li></ul><h2 id="Transforming-Operators"><a href="#Transforming-Operators" class="headerlink" title="Transforming Operators"></a>Transforming Operators</h2><p>event element의 값을 조작할 때 사용하는 Operator</p><ul><li>toArray()</li><li>map()</li><li>flatMap()</li><li>flatMapLatest()</li><li>materialize()</li><li>dematerialize()</li></ul><h2 id="Combining-Operators"><a href="#Combining-Operators" class="headerlink" title="Combining Operators"></a>Combining Operators</h2><p>Observable을 서로 결함함에 있어서 이벤트를 구독하는 순서, 방법을 결정하는 Operator</p><ul><li>startWith()</li><li>concat()</li><li>concatMap()</li><li>merge()</li><li>zip()</li><li>combineLatest()</li><li>withLatestFrom()</li><li>switchLatest()</li><li>flatMapLatest()</li><li>reduce()</li><li>scan()</li></ul><p>** 각 메소드에 대한 설명, 서비스 구현에서 적용해야 하는 타이밍 추가 예정</p>]]></content>
    
    <summary type="html">
    
      Operator
Operator는 Observable 객체를 구독할 때 넘어오는 event를 Filtering, Transforming, Combining 하기 위해 사용한다.
Observable을 구독할 때 event의 element를 그대로 사용할 수 없는 경우, 서비스에서 사용 가능한 객체로 변환하는 과정을 담당한다.

RxSwift에서는 구현에 필요한 다양한 개념들을 Operator로 미리 구현해 놓았으며 상황에 따라 적절한 Operator를 선택해 사용해야 한다.
너무 많아서 모두 예제로 만들기에는 너무 많아서 목록만 나열
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/categories/iOS/RxSwift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>[RxSwift] 2일차, RxSwift에서 지원하는 Subject에 대한 이해</title>
    <link href="http://monibu1548.github.io/2018/10/13/rxswift-subject/"/>
    <id>http://monibu1548.github.io/2018/10/13/rxswift-subject/</id>
    <published>2018-10-13T13:43:13.000Z</published>
    <updated>2018-10-13T13:44:40.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>Subject는 Observable과 Observer 두가지 역할을 한다. 즉, onNext() 메소드를 통해서 Event를 발생시키는 Observable의 역할과, subscribe 메소드를 통해 Event Sequence에서 Event를 구독하여 처리할 수 있는 Observer의 역할을 모두 수행할 수 있다.</p><p>RxSwift에서는 4가지 종류의 Subject를 지원한다.</p><ul><li>PublishSubject</li><li>BehaviorSubject</li><li>ReplySubject</li><li>Variables (Deprecated 예정)</li></ul><h2 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h2><p>가장 일반적인 Subject이다. Observable의 특징대로 subscribe 되면 event sequence에서 event를 받으며 terminated(error 또는 completed)가 되면 더이상 event를 수신하지 않는다.</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// completed</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"G"</span>)</span><br><span class="line">subject.onNext(<span class="string">"H"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br><span class="line">completed</span><br><span class="line">disposed</span><br></pre></td></tr></table></figure><p>PublishSubject가 생성되고 A, B, C… 의 event sequence를 갖는다고 할 때,<br>observer1은 “C” event 이후에 구독을 시작한다.</p><p>따라서 <code>D</code> Event 부터 수신하며 Completed Event를 수신한 이후에는 더이상 G, H는 수신하지 않는다.</p><h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>Behavior Subject의 가장 큰 특징은 initial Value를 갖는다는 것이다. 따라서 Behavior Subject를 생성시에는 반드시 초기값을 입력해야한다.<br>Observer측면에서 보면 구독과 동시에 initial Event를 수신한다. initial Event는 가장 최근에 발생한 Event를 의미한다.<br>Subject가 처음 생성되었다면 생성시 입력된 initial value를, event sequence 중간에 subscribe했다면 가장 최근의 event를 수신한다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"Initial Value"</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// completed</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"G"</span>)</span><br><span class="line">subject.onNext(<span class="string">"H"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">C</span></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br><span class="line">completed</span><br><span class="line">disposed</span><br></pre></td></tr></table></figure><p>PublishSubject 예제에서 PublishSubject를 BehaviorSubject로 변경 후의 결과이다.<br>observer1이 subscribe를 하면서 가장 최근에 발생한 Event <code>C</code>를 가져온다는 차이점이 있다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"Initial Value"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">Initial</span> <span class="type">Value</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br></pre></td></tr></table></figure><h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>ReplaySubject는 Buffer를 갖는다. Buffer에 Event를 Queue로 저장하며 subscribe 하면 buffer에 있는 event sequence 부터 수신하기 시작한다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br></pre></td></tr></table></figure><p>Buffer를 2로 ReplaySubject를 생성한 후 subscribe한 결과이다. 가장 최근에 발생한 B, C 를 크기가 2인 Buffer에 저장하고 있다가 subscribe가 되면 Event를 전달한다.</p><p>Buffer크기보다 이전에 발생했던 이벤트 갯수가 적으면 어떻게 될까?</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br></pre></td></tr></table></figure><p>Buffer가 가득차지 않았을 뿐, Buffer에 있는 Event들을 순서대로 구독하는데 문제가 없다.</p><p>그렇다면 subscribe 이전에 onCompleted가 발생한 경우에는 어떻게 될까?</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// onCompleted</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line">completed</span><br><span class="line">disposed</span><br></pre></td></tr></table></figure><p>onCompleted 발생 이전의 Event들은 Buffer에 그대로 유지되며 onCompleted 까지 Event Sequence가 전달된다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>Variables를 제외한 3가지 타입(Publish, Behavior, Replay)의 Subject에 대해 예제를 통해 학습했다.<br>각각의 Subject는 Event Sequence에 대한 처리시점에 따라 구분되어 있으며, 실제 프로젝트에 적용할 때 적절한 선택이 필요해 보인다!</p>]]></content>
    
    <summary type="html">
    
      Subject
Subject는 Observable과 Observer 두가지 역할을 한다. 즉, onNext() 메소드를 통해서 Event를 발생시키는 Observable의 역할과, subscribe 메소드를 통해 Event Sequence에서 Event를 구독하여 처리할 수 있는 Observer의 역할을 모두 수행할 수 있다.

RxSwift에서는 4가지 종류의 Subject를 지원한다.

 * PublishSubject
 * BehaviorSubject
 * ReplySubject
 * Variables (Deprecated 예정
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/categories/iOS/RxSwift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>[RxSwift] 1일차, RxSwift란, Observable에 대한 이해</title>
    <link href="http://monibu1548.github.io/2018/10/11/rxswift-observable/"/>
    <id>http://monibu1548.github.io/2018/10/11/rxswift-observable/</id>
    <published>2018-10-11T12:18:51.000Z</published>
    <updated>2018-10-11T12:48:13.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h1><p>정의 : Observable Sequense와 함수형 operator를 이용한 이벤트 기반의 비동기 프로그래밍 라이브러리.</p><h3 id="참고-iOS-SDK에서-지원하는-비동기-프로그래밍"><a href="#참고-iOS-SDK에서-지원하는-비동기-프로그래밍" class="headerlink" title="참고) iOS SDK에서 지원하는 비동기 프로그래밍"></a>참고) iOS SDK에서 지원하는 비동기 프로그래밍</h3><ol><li>NotificationCenter</li><li>Delegate Pattern</li><li>GCD (Grand Central Dispatch)</li><li>Closure</li></ol><h2 id="Rx를-시작하기-전에-해야-할-용어정리"><a href="#Rx를-시작하기-전에-해야-할-용어정리" class="headerlink" title="Rx를 시작하기 전에 해야 할 용어정리"></a>Rx를 시작하기 전에 해야 할 용어정리</h2><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>DataType에 대한 변하지 않는 상태값의 이벤트를 만들어 전달 할 수 있는 능력(프로토콜)</p><p>실제 RxSwift 라이브러리 코드를 뜯어보면,</p><p>ObservableConvertibleType (최상위 프로토콜)<br>ObservableType<br>Observable (하위 프로토콜의 최종 구현체) 로 구성되며</p><p>데이터타입이 Observable할 수 있도록 프로토콜을 통해 구현하게 한다.</p><p>Observable의 LifeCycle을 살펴보면</p><ol><li>next 이벤트를 던진다, terminated 되기 전까지.</li><li>completed or Error를 던지면 terminated된다.</li><li>terminated 되면 더이상 이벤트를 던지지 않는다.</li></ol><p>여기에서 Event란, 인스턴스가 변화하는 상태값을 의미한다. 각각의 상태값은 Observable 이벤트가 흘러가는 동안 immutable 속성을 갖는다.</p><p>이벤트의 흐름을 Observable Sequense라고 하며, 보통 Marvel diagram으로 시각화한다.</p><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>Swift에서 기본적으로 제공하는 Array의 filter, map, reduce와 같은 맥락의 커스텀 메소드라고 생각하면 된다.<br>Observable도 결국 Event 흐름 Array로 각 로직에 맞는 커스텀 Operator를 작성해야 한다.<br>각각의 Operator는 Input, Output이 명확하게 설계하여 사이드이펙트를 줄이고 단위테스트를 용이하게 할 수 있다.</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>RxSwift라이브러리에서 Dispatch Queue의 역할을 하는 개념.<br>결국 Observable을 통해 이벤트를 수신할 수 있도록 하는 스타터.</p><p>Scheduler는 커스텀 없이 RxSwift에서 제공하는 기능만으로도 99%를 커버할 수 있다고 한다.</p><h1 id="RxSwift-실습"><a href="#RxSwift-실습" class="headerlink" title="RxSwift 실습"></a>RxSwift 실습</h1><ul><li>실습에 필요한 환경 : XCode, CocoaPod</li></ul><ol><li>Swift Project를 생성 후 pod init을 통해 Podfile생성</li><li>Podfile에 pod ‘RxSwift’ 추가 후 pod install</li><li>xcworkspace 실행. 빌드.</li><li>프로젝트 내에 playground 파일 생성 후 RxSwift import</li></ol><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>1.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p>range 메소드는 start, count 내의 Event Sequence를 만든다</p><ol start="2"><li><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure></li></ol><p>of 메소드에 sequence를 넘기면 순서대로 Event Sequence가 생성된다.</p><p>3.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>])</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>]</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p>of 메소드에 배열을 넘길 경우 배열 그 자체에 대한 Event가 생성된다.</p><p>4.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.from([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>])</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p>from 메소드를 사용하면 배열 객체의 각 element에 대한 event sequence가 생성된다.</p><h2 id="실제-프로젝트-개발에서의-적용"><a href="#실제-프로젝트-개발에서의-적용" class="headerlink" title="실제 프로젝트 개발에서의 적용"></a>실제 프로젝트 개발에서의 적용</h2><p>위의 예제는 정적인 배열 또는 클래스에 대한 Event 생성으로, 학습용일뿐 실제 프로젝트에는 적용할 수 없다.<br>실제 프로젝트에 적용하기 위해서는 Runtime에 외부 요건(네트워크 통신, 사용자의 입력)에 대한 Event Sequence를 사용해야한다.</p><p>Rx에 대한 이해를 바탕을 Observable한 사용자 클래스, 적절한 Operator를 이용해 적용한다.</p>]]></content>
    
    <summary type="html">
    
      RxSwift
정의 : Observable Sequense와 함수형 operator를 이용한 이벤트 기반의 비동기 프로그래밍 라이브러리.

참고) iOS SDK에서 지원하는 비동기 프로그래밍
 1. NotificationCenter
 2. Delegate Pattern
 3. GCD (Grand Central Dispatch)
 4. Closure

Rx를 시작하기 전에 해야 할 용어정리
Observable
DataType에 대한 변하지 않는 상태값의 이벤트를 만들어 전달 할 수 있는 능력(프로토콜)

실제 RxSwift 라이브러리
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/categories/iOS/RxSwift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>[iOS] In-App-Purchase 인앱구매 적용기</title>
    <link href="http://monibu1548.github.io/2018/08/29/iap/"/>
    <id>http://monibu1548.github.io/2018/08/29/iap/</id>
    <published>2018-08-29T12:44:16.000Z</published>
    <updated>2018-08-29T13:06:05.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="수익을-내보자"><a href="#수익을-내보자" class="headerlink" title="수익을 내보자"></a>수익을 내보자</h1><p>지금까지는 AdMob을 통해 광고 수익을 소소하게 벌고 있었는데요. 이번엔 인앱구매를 통해 수익모델을 붙여보려고 합니다.<br>보통 주로 무료앱에서는 광고 제거 버전을 인앱구매 상품으로 판매중입니다.</p><p>저도 한번 인앱구매로 광고제거 버전을 만들어 보려고 합니다.</p><h2 id="앱-설정-변경하기"><a href="#앱-설정-변경하기" class="headerlink" title="앱 설정 변경하기"></a>앱 설정 변경하기</h2><p>지금까지 Push 등 앱에 특별한 기능을 추가하기 위해서는 애플 개발자 센터에서 옵션 설정을 해왔습니다.<br>인앱구매도 마찬가지로 <a href="https://developer.apple.com/" target="_blank" rel="noopener">애플 개발자 센터</a>에서 인앱구매 기능을 사용하겠다고 설정해야합니다.</p><p><img src="../../../../images/iap/1.png" alt=""></p><p>앱의 설정을 변경하기 위해 애플 개발자 센터에서 앱 설정 페이지로 들어갑니다.</p><p><img src="../../../../images/iap/2.png" alt=""></p><p>In-App Purchase 를 Enable로 만들어줍니다! 저는 왜때문인지 이미 되어있네요…</p><h2 id="상품-등록하기"><a href="#상품-등록하기" class="headerlink" title="상품 등록하기"></a>상품 등록하기</h2><p>이제 앱에서 판매할 상품을 등록해야합니다. 상품 등록은 애플 개발자 센터가 아닌 <a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">아이튠스커넥트</a>에서 진행합니다.</p><p><img src="../../../../images/iap/3.png" alt=""></p><p>상품을 판매할 앱의 상세 페이지에서 <code>앱 내 추가기능</code> 탭을 선택합니다.</p><ul><li>버튼을 눌러봅니다.</li></ul><p><img src="../../../../images/iap/4.png" alt=""></p><p>판매할 제품의 속성을 선택합니다.</p><ul><li>소모품 : 말 그대로 소모품입니다. 유저가 필요할 때마다 구입하는 제품입니다.</li><li>비소모품 : 한번 구매하면 아이튠즈 기록을 통해 복원이 가능한 계정에 종속되는 제품입니다.</li><li>비자동 갱신구독 : 기간 제한을 둔 제품을 판매합니다. 유저는 기한이 끝나면 재구매 가능합니다.</li></ul><p>이번 앱에서는 구매를 통해 광고제거 기능확장을 제공할 예정입니다. <code>비소모품</code>을 선택합니다.</p><p><img src="../../../../images/iap/5.png" alt=""></p><p>가격 정보 등 판매할 제품의 정보를 입력합니다.<br>심사 정보는 나중에 기입합니다.</p><h2 id="앱에-기능-구현하기"><a href="#앱에-기능-구현하기" class="headerlink" title="앱에 기능 구현하기"></a>앱에 기능 구현하기</h2>]]></content>
    
    <summary type="html">
    
      수익을 내보자
지금까지는 AdMob을 통해 광고 수익을 소소하게 벌고 있었는데요. 이번엔 인앱구매를 통해 수익모델을 붙여보려고 합니다.
보통 주로 무료앱에서는 광고 제거 버전을 인앱구매 상품으로 판매중입니다.

저도 한번 인앱구매로 광고제거 버전을 만들어 보려고 합니다.

앱 설정 변경하기
지금까지 Push 등 앱에 특별한 기능을 추가하기 위해서는 애플 개발자 센터에서 옵션 설정을 해왔습니다.
인앱구매도 마찬가지로 애플 개발자 센터에서 인앱구매 기능을 사용하겠다고 설정해야합니다.



앱의 설정을 변경하기 위해 애플 개발자 센터에서
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>[iOS] AppDelegate의 역할과 메소드</title>
    <link href="http://monibu1548.github.io/2018/08/28/appdelegate/"/>
    <id>http://monibu1548.github.io/2018/08/28/appdelegate/</id>
    <published>2018-08-28T12:31:47.000Z</published>
    <updated>2018-08-28T13:44:56.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AppDelegate-의-역할"><a href="#AppDelegate-의-역할" class="headerlink" title="AppDelegate 의 역할"></a>AppDelegate 의 역할</h1><p>UITableViewDelegate를 구현하다 =&gt; UITableView에서 필요한 기능을 대신 구현하다<br>라는 느낌으로 AppDelegate는 App( Application ) 이 해야할 일을 대신 구현한다는 의미입니다.</p><p>여기에서 App이 해야할 일이란, Background 진입, Foreground 진입, 외부에서의 요청 (apns) 등을 말합니다.</p><h3 id="UIApplicationMain-은-뭘까요"><a href="#UIApplicationMain-은-뭘까요" class="headerlink" title="@UIApplicationMain 은 뭘까요?"></a>@UIApplicationMain 은 뭘까요?</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span></span></span><br></pre></td></tr></table></figure><p>지워보면 알겠죠. 주석처리 해봅니다. 네 에러가 나죠.<br><img src="../../../../images/appdelegate/1.png" alt=""></p><p>실제로 앱은 UIApplication이라는 객체로 추상화 되어 Run Loop를 통해 프로그램 코드를 실행합니다. 개발자는 AppDelegate를 통해 UIApplication의 역할의 일부를 위임받아 UI를 그리면서 앱 다운 앱이 탄생합니다.</p><p>여기서 의문.</p><p>UIApplication은 AppDelegate.m 파일에 있는 AppDelegate 클래스가 본인의 역할을 위임받은 클래스인지 어떻게 알까요?</p><p>보통 <code>tableView.delegate = {UITableViewDelegate를 구현한 객체}</code> 이런식으로 Delegate를 연결하죠.<br>그런데 앱을 실행할 때,,, UIApplication객체를 가져와서 delegate를…..</p><p>결론은 @UIApplication 어노테이션입니다.</p><p>@UIApplication 어노테이션이 붙은 사용자 정의 클래스를 UIApplication의 delegate로 사용합니다.</p><h3 id="UIWindow"><a href="#UIWindow" class="headerlink" title="UIWindow"></a>UIWindow</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br></pre></td></tr></table></figure><p>AppDelegate클래스를 보면 유일한 변수가 하나 있습니다. window<br>UIWindow 클래스이며 Optional로 nil을 가질 수 있습니다.</p><p>스토리보드 기반의 앱으로 구동되면 시스템에서 UIWindow객체를 할당하여 초기화하며, 코드기반의 경우 didFinishLaunchingWithOptions 타이밍에 직접 생성해줘야 합니다.</p><p>UIWindow 는 View를 담는 컨테이너 역할이며 다른 포스팅에서 더 자세히 다루도록 합니다.</p><h2 id="AppDelegate-메소드로-보는-iOS-LifeCycle"><a href="#AppDelegate-메소드로-보는-iOS-LifeCycle" class="headerlink" title="AppDelegate 메소드로 보는 iOS LifeCycle"></a>AppDelegate 메소드로 보는 iOS LifeCycle</h2><h3 id="1-앱-실행"><a href="#1-앱-실행" class="headerlink" title="1. 앱 실행"></a>1. 앱 실행</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>앱을 실행하면 호출되는 delegate 메소드. launchOptions 파라미터로 앱이 실행되게 된 이유 (푸시를 통한 실행) 등이 포함되어 실행된다.</p><ul><li>return은 왜 true로 고정되어 있을까?</li></ul><p>false로 바꿔도 앱은 정상적으로 실행되며, 아무 문제 없다.<br>return 값은 앱이 URL ( App Scheme ) 으로 실행된 경우 유효하다. URL로 실행 된 경우 launchOptions에 URL이 넘어오며 return을 false로 하면 openURL로 url을 오픈하지 않고 넘어간다.</p><ul><li>좀 더 연구가 필요!</li></ul><h3 id="2-앱-활성화"><a href="#2-앱-활성화" class="headerlink" title="2. 앱 활성화"></a>2. 앱 활성화</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidBecomeActive</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>앱이 화면에 뜬 이후 실행되는 메소드. 사실 WillBecomeActive도 있지만 자주 사용하지 않아서인지 AppDelegate에 기본적으로 override된 메소드는 applicationDidBecomeActive 였다.<br>앱이 백그라운드로 간 이후, 다시 포어그라운드로 올라온 이후에도 실행되는 메소드입니다.</p><h3 id="3-홈-버튼을-누르면"><a href="#3-홈-버튼을-누르면" class="headerlink" title="3. 홈 버튼을 누르면"></a>3. 홈 버튼을 누르면</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillResignActive</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</span></span><br><span class="line">        <span class="comment">// Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>홈 버튼을 누르면 앱은 백그라운드로 이동합니다. 가장 먼저 App이 포커스를 잃으면서 실행되는 메소드입니다.<br>템플릿 설명에 다르면 태스크 일시정지, 타이머 비활성화, 게임의 경우 일시정지를 처리하는 로직을 구현해야 하는 메소드입니다.</p><h3 id="4-백그라운드로-이동-후-화면에서-앱-안보임"><a href="#4-백그라운드로-이동-후-화면에서-앱-안보임" class="headerlink" title="4. 백그라운드로 이동 후 (화면에서 앱 안보임)"></a>4. 백그라운드로 이동 후 (화면에서 앱 안보임)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidEnterBackground</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span></span><br><span class="line">        <span class="comment">// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>앱이 백그라운드로 이동하여 더이상 앱이 보이지 않은 이후 호출되는 메소드.<br>이 메소드에서는 공유자원 해제, 유저 데이터 저장 등의 로직을 구현해야합니다.</p><h3 id="5-다시-앱-실행-메모리에-아직-살아있는-경우"><a href="#5-다시-앱-실행-메모리에-아직-살아있는-경우" class="headerlink" title="5. 다시 앱 실행 (메모리에 아직 살아있는 경우)"></a>5. 다시 앱 실행 (메모리에 아직 살아있는 경우)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillEnterForeground</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>자주 사용하는 메소드입니다.<br>앱이 다시 포어그라운드로 올라올 때 호출되는 메소드로, 보통 API를 통해 앱의 상태를 갱신할 때 사용합니다. 버전체크, 메인테이닝 체크 등..</p>]]></content>
    
    <summary type="html">
    
      AppDelegate 의 역할
UITableViewDelegate를 구현하다 =&gt; UITableView에서 필요한 기능을 대신 구현하다
라는 느낌으로 AppDelegate는 App( Application ) 이 해야할 일을 대신 구현한다는 의미입니다.

여기에서 App이 해야할 일이란, Background 진입, Foreground 진입, 외부에서의 요청 (apns) 등을 말합니다.

@UIApplicationMain 은 뭘까요?
1
2


@UIApplicationMain
class AppDelegate: UIResponder, 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>[Swift] iOS Widget Development. 위젯 iOS 앱 개발하기</title>
    <link href="http://monibu1548.github.io/2018/07/07/widget/"/>
    <id>http://monibu1548.github.io/2018/07/07/widget/</id>
    <published>2018-07-07T10:23:30.000Z</published>
    <updated>2018-07-07T14:46:26.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p><img src="../../../../images/widget/1.jpeg" alt=""></p><p>iOS11.3을 사용하고 있는 iPhone7 에서의 Widget 화면입니다. 앱 서비스 특징에 따라 위젯이 있으면 편리한 경우가 있습니다.</p><p>이번에 세번째로 52시간 근무시간 제도 시행에 맞춰 근무 시간을 체크할 수 있는 <code>퇴근요정</code> 앱을 배포했는데요.</p><p>다음 버전에서는 위젯도 제공하면 좋을 것 같아 공부도 할 겸 포스팅을 진행합니다.</p><h2 id="Widget-Target-생성"><a href="#Widget-Target-생성" class="headerlink" title="Widget Target 생성"></a>Widget Target 생성</h2><ol><li><p>위젯을 개발할 앱 프로젝트를 XCode에서 Open합니다.</p></li><li><p>File &gt; New &gt; Target 을 클릭합니다.</p></li></ol><p><img src="../../../../images/widget/2.png" alt=""></p><ol start="3"><li><p>Today Extension을 선택합니다. TodayExtension이 Widget을 말합니다.</p></li><li><p>Product Name을 입력합니다. 저는 그냥 Widget으로 만들었어요.</p></li><li><p>Target을 Widget으로 변경 후, 실행해봅니다.</p></li></ol><p><img src="../../../../images/widget/3.png" alt=""></p><ol start="6"><li>위젯 편집화면에서 WIDGET이 추가되었으며, 노출하게 설정하면 다음과 같이 <code>Hello World</code> 를 노출합니다.</li></ol><p><img src="../../../../images/widget/4.png" alt=""><br><img src="../../../../images/widget/5.jpeg" alt=""></p><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>Widget의 UI는 스토리보드를 이용합니다. Target 생성을 하면 자동으로 스토리보드 1개, 컨트롤러 1개, plist 1개가 추가되네요.</p><p>XCode가 만들어준 MainInterface.storyboard에 UI를 그려줍니다</p><p><img src="../../../../images/widget/6.png" alt=""></p><p>이걸 빌드하면</p><p><img src="../../../../images/widget/7.jpeg" alt=""></p><p>이렇게 나옵니다!!</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> NotificationCenter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetViewController</span>: <span class="title">UIViewController</span>, <span class="title">NCWidgetProviding</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view from its nib.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">widgetPerformUpdate</span><span class="params">(completionHandler: <span class="params">(@escaping <span class="params">(NCUpdateResult)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">        <span class="comment">// Perform any setup necessary in order to update the view.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If an error is encountered, use NCUpdateResult.Failed</span></span><br><span class="line">        <span class="comment">// If there's no update required, use NCUpdateResult.NoData</span></span><br><span class="line">        <span class="comment">// If there's an update, use NCUpdateResult.NewData</span></span><br><span class="line">        </span><br><span class="line">        completionHandler(<span class="type">NCUpdateResult</span>.newData)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 XCode에서 TodayExtension Target 생성시 자동으로 생성되는 템플릿 코드입니다.<br>viewDidLoad와 didReceiveMemoryWarning의 경우 일반 뷰컨트롤러와 별다를게 없습니다.</p><p>중요한건 <code>widgetPerformUpdate</code> 메소드 입니다. 위젯 페이지에서의 스크롤 등 위젯 업데이트가 필요한 경우 호출됩니다.<br>위 메소드에서 위젯 뷰에서 보여줄 내용을 업데이트 하면 됩니다.</p><p>자 그러면, 이제 WidgetViewController에서 기존 앱에서 사용하던 모듈을 가져와서 UI를 업데이트 작업을 하면 될 것 같은데..?</p><p>자동완성이 안되죠.</p><p>가져올 모듈 파일을 열고 Target membership을 설정해줘야합니다.</p><p><img src="../../../../images/widget/8.png" alt=""></p><p>쨘. 그럼 이제 자동완성이 되지요.</p><h2 id="망했다"><a href="#망했다" class="headerlink" title="망했다"></a>망했다</h2><p>기존 근무시간 데이터를 SQlite3를 이용해서 관리를 하고있었고, sharedInstance를 통해 CRUD를 진행중이었습니다.</p><p>위젯에서 불러오려고 하니… 위젯은 DB를 못읽어..오는 것..같네요.. :)</p><p>위젯에서는 API Request를 통해 UI를 갱신하는게 바람직해 보입니다. ㅠㅜ</p>]]></content>
    
    <summary type="html">
    
      Widget


iOS11.3을 사용하고 있는 iPhone7 에서의 Widget 화면입니다. 앱 서비스 특징에 따라 위젯이 있으면 편리한 경우가 있습니다.

이번에 세번째로 52시간 근무시간 제도 시행에 맞춰 근무 시간을 체크할 수 있는 퇴근요정 앱을 배포했는데요.

다음 버전에서는 위젯도 제공하면 좋을 것 같아 공부도 할 겸 포스팅을 진행합니다.

Widget Target 생성
 1. 위젯을 개발할 앱 프로젝트를 XCode에서 Open합니다.
    
    
 2. File &gt; New &gt; Target 을 클릭합니다.
    
 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Swift4 환경에서 sqlite3 DB 사용하기</title>
    <link href="http://monibu1548.github.io/2018/07/03/sqlite3/"/>
    <id>http://monibu1548.github.io/2018/07/03/sqlite3/</id>
    <published>2018-07-03T14:38:18.000Z</published>
    <updated>2018-07-04T11:44:46.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sqlite3를-이용하여-CRUD-구현하기"><a href="#Sqlite3를-이용하여-CRUD-구현하기" class="headerlink" title="Sqlite3를 이용하여 CRUD 구현하기"></a>Sqlite3를 이용하여 CRUD 구현하기</h2><p>Serverless한 앱을 주로 만들면 데이터를 로컬에 저장하게 되는데, 주로 UserDefault를 사용합니다. 데이터가 단순하고 양이 많지 않다면 상관없지만 CRUD 횟수가 많고 데이터 양이 많다면<br>Database 를 사용하는게 바람직합니다.</p><p>iOS Swift4환경에서 Sqlite3를 이용해서 데이터 CRUD를 구현하는 과정을 설명합니다.</p><h2 id="import-Sqlite3"><a href="#import-Sqlite3" class="headerlink" title="import Sqlite3"></a>import Sqlite3</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SQLite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkingTimeDBManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>근무시간을 관리하는 데이터를 저장하는 앱을 제작중입니다. 근무시간을 저장하기 위한 역할을 하는 WorkingTimeDBManager를 구현합니다.<br><code>import SQLite3</code> 로 해당 파일에서 SQLite3 모듈을 사용할 수 있도록 선언합니다.</p><p>WorkingTime 모델은</p><p>id : Primary 키<br>start : 근무 시작 시간<br>end : 근무 종료 시간</p><p>로 구성할 예정입니다.</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>가장 기본이 되는 CRUD 메소드를 선언합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createWorkingTime</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updateWorkingTime</span><span class="params">(id: Int, start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">readWorkingTimes</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">deleteWorkingTime</span><span class="params">(id: Int)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CRUD-Create"><a href="#CRUD-Create" class="headerlink" title="CRUD - Create"></a>CRUD - Create</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createWorkingTime</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> insertStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">let</span> insertStatementString = <span class="string">"INSERT INTO WorkingTimes (start, end) VALUES (?, ?);"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, insertStatementString, -<span class="number">1</span>, &amp;insertStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            </span><br><span class="line">            sqlite3_bind_int(insertStatement, <span class="number">1</span>, <span class="type">Int32</span>(start.timeIntervalSince1970))</span><br><span class="line">            sqlite3_bind_int(insertStatement, <span class="number">2</span>, <span class="type">Int32</span>(end.timeIntervalSince1970))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sqlite3_step(insertStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">                <span class="comment">// Success</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//Fail</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        sqlite3_finalize(insertStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>근무시간을 저장하는 메소드입니다. 근무시작시간과 종료 시간을 받아서 <code>WorkingTimes</code> 테이블에 start, end 컬럼에 데이터를 추가합니다. id 컬럼은 테이블 선언시 AUTOINCREMENT로 선언했습니다.</p><h3 id="CRUD-Read"><a href="#CRUD-Read" class="headerlink" title="CRUD - Read"></a>CRUD - Read</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">readWorkingTimes</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> queryStatementString = <span class="string">"SELECT * FROM WorkingTimes;"</span></span><br><span class="line">        <span class="keyword">var</span> queryStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, queryStatementString, -<span class="number">1</span>, &amp;queryStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> sqlite3_step(queryStatement) == <span class="type">SQLITE_ROW</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> id = sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> queryResultCol1 = sqlite3_column_int(queryStatement, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">let</span> queryResultCol2 = sqlite3_column_int(queryStatement, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"<span class="subst">\(id)</span> | <span class="subst">\(queryResultCol1)</span> | <span class="subst">\(queryResultCol2)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fail</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sqlite3_finalize(queryStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WorkingTimes</code> 테이블의 모든 ROW를 읽어옵니다. while 문을 통해 읽어온 모든 ROW 에 대해 처리합니다.</p><h3 id="CRUD-Update"><a href="#CRUD-Update" class="headerlink" title="CRUD - Update"></a>CRUD - Update</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updateWorkingTime</span><span class="params">(id: Int, start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> updateStatementString = <span class="string">"UPDATE WorkingTimes SET start = "</span> +</span><br><span class="line">            <span class="type">String</span>(start.timeIntervalSince1970) +</span><br><span class="line">            <span class="string">", end = "</span> +</span><br><span class="line">            <span class="type">String</span>(end.timeIntervalSince1970) +</span><br><span class="line">        <span class="string">" WHERE id = "</span> + <span class="type">String</span>(id)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> updateStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, updateStatementString, -<span class="number">1</span>, &amp;updateStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sqlite3_step(updateStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">                <span class="comment">// Success</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fail</span></span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(updateStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>id에 해당하는 ROW 를 찾아서 start와 end column을 갱신합니다.</p><h3 id="CRUD-Delete"><a href="#CRUD-Delete" class="headerlink" title="CRUD - Delete"></a>CRUD - Delete</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">deleteWorkingTime</span><span class="params">(id: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> deleteStatementStirng = <span class="string">"DELETE FROM WorkingTimes WHERE id = "</span> + <span class="type">String</span>(id)</span><br><span class="line">        <span class="keyword">var</span> deleteStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, deleteStatementStirng, -<span class="number">1</span>, &amp;deleteStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sqlite3_step(deleteStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">                <span class="comment">// Success</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fail</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sqlite3_finalize(deleteStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WorkingTimes</code> 테이블에서 전달인자로 넘어온 id 에 해당하는 ROW 를 제거합니다.</p>]]></content>
    
    <summary type="html">
    
      Sqlite3를 이용하여 CRUD 구현하기
Serverless한 앱을 주로 만들면 데이터를 로컬에 저장하게 되는데, 주로 UserDefault를 사용합니다. 데이터가 단순하고 양이 많지 않다면 상관없지만 CRUD 횟수가 많고 데이터 양이 많다면
Database 를 사용하는게 바람직합니다.

iOS Swift4환경에서 Sqlite3를 이용해서 데이터 CRUD를 구현하는 과정을 설명합니다.

import Sqlite3
1
2
3
4
5
6


import UIKit
import SQLite3

class WorkingTimeDBMana
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Swift" scheme="http://monibu1548.github.io/categories/iOS/Swift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Firebase Cloud Messaging, Notification (Firebase를 이용한 iOS Push 전송)</title>
    <link href="http://monibu1548.github.io/2018/05/31/firebase-push/"/>
    <id>http://monibu1548.github.io/2018/05/31/firebase-push/</id>
    <published>2018-05-31T11:46:48.000Z</published>
    <updated>2019-01-20T04:09:10.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Firebase-Cloud-Messaging"><a href="#Firebase-Cloud-Messaging" class="headerlink" title="Firebase Cloud Messaging"></a>Firebase Cloud Messaging</h2><p>지난 포스팅에서는 iOS 앱의 Push Notification 기능을 추가하는 내용을 다뤘습니다.<br><a href="http://monibu1548.github.io/2018/05/29/push-cert/">iOS APN, Push Noticifation tutorial (Push 인증서 발급, 테스트 과정)</a></p><p>이제 이 기능을 실제 서비스에서 사용하기 위해 Firebase 를 사용하는 방법을 소개합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Firebase/Core&apos;</span><br><span class="line">pod &apos;Firebase/Messaging&apos;</span><br></pre></td></tr></table></figure><p>Podfile에 Cloud Messaging 기능을 사용하기 위해 위 2pod을 설치합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p><img src="../../../../images/firebase-push/1.png" alt=""><br>Firebase 앱 설정에서 APN 키를 등록해야합니다.<br>지난 포스팅에서는 Push 인증서를 만든것이고 APN 인증키는 따로있습니다. </p><h2 id="APN-인증키-발급받기"><a href="#APN-인증키-발급받기" class="headerlink" title="APN 인증키 발급받기"></a>APN 인증키 발급받기</h2><p><img src="../../../../images/firebase-push/2.png" alt=""><br><a href="https://developer.apple.com/account/ios/authkey/" target="_blank" rel="noopener">애플 개발자센터</a>에 들어갑니다.</p><p><img src="../../../../images/firebase-push/3.png" alt=""><br>Key 이름은 적당히 적고 APNs 선택 후 Continue~!</p><p><img src="../../../../images/firebase-push/4.png" alt=""><br>쨘! APN Key가 쉽게 생성됩니다. 여기서 <code>.p8</code> APN 인증서를 다운받습니다. <code>잘 챙겨주세요!</code></p><p>자 이제 다시 Firebase로 돌아옵니다.<br><img src="../../../../images/firebase-push/5.png" alt=""><br>다운받은 APN 인증키를 넣고<br>키 ID 는 인증키 파일 뒤 suffix입니다.<br>앱 ID prefix는 teamID 입니다.</p><p><img src="../../../../images/firebase-push/6.png" alt=""><br>APN Key가 정상적으로 등록된 것을 볼 수 있습니다.</p><h2 id="XCode-에서-Firebase-Push-사용할-수-있도록-설정하기"><a href="#XCode-에서-Firebase-Push-사용할-수-있도록-설정하기" class="headerlink" title="XCode 에서 Firebase Push 사용할 수 있도록 설정하기"></a>XCode 에서 Firebase Push 사용할 수 있도록 설정하기</h2><p>AppDelegate에서 Firebase 설정하기</p><p>Appdelegate.swift 파일에 Firebase 모듈을 import 합니다</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Firebase</span><br></pre></td></tr></table></figure><p><code>application:didFinishLaunchingWithOptions:</code> 메소드에서 Firebase 모듈을 초기화합니다.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FirebaseApp</span>.configure()</span><br></pre></td></tr></table></figure></p><p>Push Notification을 등록할 위치에 다음 코드를 삽입합니다<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</span><br><span class="line">  <span class="comment">// For iOS 10 display notification (sent via APNS)</span></span><br><span class="line">  <span class="type">UNUserNotificationCenter</span>.current().delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> authOptions: <span class="type">UNAuthorizationOptions</span> = [.alert, .badge, .sound]</span><br><span class="line">  <span class="type">UNUserNotificationCenter</span>.current().requestAuthorization(</span><br><span class="line">    options: authOptions,</span><br><span class="line">    completionHandler: &#123;<span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span> &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> settings: <span class="type">UIUserNotificationSettings</span> =</span><br><span class="line">  <span class="type">UIUserNotificationSettings</span>(types: [.alert, .badge, .sound], categories: <span class="literal">nil</span>)</span><br><span class="line">  application.registerUserNotificationSettings(settings)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application.registerForRemoteNotifications()</span><br></pre></td></tr></table></figure></p><p>후후 그럼 끝났습니다.</p><h2 id="Firebase에서-Push-Notification-보내기"><a href="#Firebase에서-Push-Notification-보내기" class="headerlink" title="Firebase에서 Push Notification 보내기"></a>Firebase에서 Push Notification 보내기</h2><p><img src="../../../../images/firebase-push/7.png" alt=""><br>메세지 내용에 Push 내용을 입력합니다.</p><p>앱 드랍다운 버튼을 클릭하면 Firebase에 등록한 프로젝트들이 뜨는데요, 이 중에서 Push 보낼 앱을 선택합니다.</p><p>그리고 <code>메세지 보내기</code> 클릭!</p><p>그러면 아이폰에 remote Notification 이 뙇!</p><p>메세지를 보낼때 예약도 가능합니다.</p><p>시간대별로 적절한 푸시를 통해 사용자 진입을 늘릴 수 있습니다!</p>]]></content>
    
    <summary type="html">
    
      Firebase Cloud Messaging
지난 포스팅에서는 iOS 앱의 Push Notification 기능을 추가하는 내용을 다뤘습니다.
iOS APN, Push Noticifation tutorial (Push 인증서 발급, 테스트 과정)

이제 이 기능을 실제 서비스에서 사용하기 위해 Firebase 를 사용하는 방법을 소개합니다.

1
2


pod &#39;Firebase/Core&#39;
pod &#39;Firebase/Messaging&#39;


Podfile에 Cloud Messaging 기능을 사용하기 위해 위 2pod을 설치합니다.

1
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/categories/iOS/Firebase/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/tags/Firebase/"/>
    
      <category term="앱 고도화" scheme="http://monibu1548.github.io/tags/%EC%95%B1-%EA%B3%A0%EB%8F%84%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>iOS APN, Push Noticifation tutorial (Push 인증서 발급, 테스트 과정)</title>
    <link href="http://monibu1548.github.io/2018/05/29/push-cert/"/>
    <id>http://monibu1548.github.io/2018/05/29/push-cert/</id>
    <published>2018-05-29T11:49:03.000Z</published>
    <updated>2018-05-29T13:55:10.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="푸시-인증서-발급받기"><a href="#푸시-인증서-발급받기" class="headerlink" title="푸시 인증서 발급받기"></a>푸시 인증서 발급받기</h2><p>iOS에서 Push 기능을 사용하기 위해서 Push Certificate, 푸시 인증서가 필요합니다. 푸시 인증서를 발급받는 방법은 개발 인증서 발급과정과 비슷합니다.</p><h3 id="Apple-Developers"><a href="#Apple-Developers" class="headerlink" title="Apple Developers"></a>Apple Developers</h3><p><img src="../../../../images/push-cert/1.png" alt=""><br><a href="https://developer.apple.com/account/ios/certificate/" target="_blank" rel="noopener">애플 개발자센터</a>에 로그인합니다.</p><p><code>+</code> 버튼을 눌러줍니다.</p><p><img src="../../../../images/push-cert/2.png" alt=""><br>개발용 인증서 발급페이지와 동일합니다. 빨간색으로 표시한 부분이 Push 인증서입니다.<br>개발용 인증서와 마찬가지로 Development(개발용)와 Production(앱스토어용) 으로 분리되어 있으며 필요에 따라 생성하면 됩니다.<br>우선 Development용을 발급받습니다.</p><p><img src="../../../../images/push-cert/3.png" alt=""><br>어떤 앱의 Push 인증서를 만들 것인지 선택합니다.</p><p><img src="../../../../images/push-cert/4.png" alt=""><br>CSR(Certificate Signing Request)가 필요하다는 안내 페이지입니다.<br>CSR발급은 앱 인증서 발급 과정을 참고해주세요.</p><p><a href="http://monibu1548.github.io/2018/04/15/apple-development/">iOS Application 개발 시작하기 - 1 (개발자 등록, 인증서 등록)</a></p><p><img src="../../../../images/push-cert/5.png" alt=""><br>CSR파일을 선택하고 Continue 버튼을 클릭합니다.</p><p><img src="../../../../images/push-cert/6.png" alt=""><br>Push인증서 발급이 완료되었습니다. 같은 과정으로 Production환경의 Push인증서도 발급받습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">참고로 Push 인증서는 앱 인증서처럼 개발 맥북에 등록하여 사용하는 것이 아닙니다.</span><br><span class="line">Push용 인증서는 iOS앱에 Push Notification을 발생시킬 때 사용하는 인증서입니다.</span><br></pre></td></tr></table></figure><h2 id="프로비저닝-재발급"><a href="#프로비저닝-재발급" class="headerlink" title="프로비저닝 재발급"></a>프로비저닝 재발급</h2><p>지난번 프로비저닝 발급 포스트(<a href="http://monibu1548.github.io/2018/04/15/apple-development/">iOS Application 개발 시작하기 - 1 (개발자 등록, 인증서 등록)</a>)에서 프로비저닝에는 Certificate 정보가 포함된다고 소개했습니다.</p><p>따라서, Push를 위해 Certificate를 재발급 받았으니 프로비저닝도 재발급 받아야 합니다.<br>이런 귀찮음을 피하기 위해서는 앱 개발 프로젝트 초기단계에 한번에 다 발급받는 것도 방법입니다 :)</p><p><img src="../../../../images/push-cert/7.png" alt=""><br>프로비저닝을 재발급 받기위해 위 페이지에 접속하면 아마 빨간색 부분이 <code>invalid</code>라고 뜰겁니다. 저는 이미 재발급을 받아버려서 active라고 나옵니다.<br>이 프로비저닝을 Delete하고 재발급 받아도 되지만 <code>Edit</code> 버튼으로 들어가서 <code>Generate</code> 해주면 자동으로 Push Certificate 가 업데이트 된 프로비저닝을 쉽게 받을 수도 있습니다.</p><p><img src="../../../../images/push-cert/8.png" alt=""><br>프로비저닝 정보를 보면 <code>Push Notifications</code>가 추가된 것을 볼 수 있습니다.</p><p>다운로드받아서 더블클릭! 해주세요.</p><h2 id="XCode-프로젝트-설정"><a href="#XCode-프로젝트-설정" class="headerlink" title="XCode 프로젝트 설정"></a>XCode 프로젝트 설정</h2><p>이제 프로젝트 설정에 들어가서 Push를 사용하겠다고 선언해봅시다.<br>XCode를 열고 프로젝트 파일 -&gt; <code>Capabilities</code> 탭으로 진입합니다.</p><p><img src="../../../../images/push-cert/9.png" alt=""><br>네, 친절하게 <code>Push Notifications</code>라고 있습니다. Off -&gt; On 으로 변경해줍니다.</p><p><img src="../../../../images/push-cert/10.png" alt=""><br>지금까지 잘 진행했다면 위와 같이 2개의 체크!를 볼 수 있습니다. 프로비저닝 또는 Push 인증서에 문제가 있다면 이곳에 표시됩니다.</p><h2 id="Push-Permission-획득"><a href="#Push-Permission-획득" class="headerlink" title="Push Permission 획득"></a>Push Permission 획득</h2><p>이제 정말 Push가 오는지, 보낼 수 있는지 확인이 필요합니다.</p><p><code>AppDelegate</code>파일의 didFinishLaunchingWithOptions 메소드에 다음의 코드를 작성합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">UNUserNotificationCenter</span>.current().requestAuthorization(options: [.alert, .sound, .badge]) &#123;</span><br><span class="line">        (granted, error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> granted <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            application.registerForRemoteNotifications()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/push-cert/11.jpeg" alt=""><br>Push도 위치정보, 사진정보등과 같이 Native를 활용하기 때문에 사용자의 권한 동의가 필요하기 때문에 동의를 얻는 코드입니다.<br>위의 코드를 넣으면 앱 실행시 사용자에게 다음과 같은 Alert으로 알람 동의를 얻습니다.</p><h2 id="Device-Token-확인"><a href="#Device-Token-확인" class="headerlink" title="Device Token 확인"></a>Device Token 확인</h2><p>이제 디바이스 토큰 확인을 위해 AppDelegate파일에 <code>didRegisterForRemoteNotificationsWithDeviceToken</code> 메소드를 오버라이드 합니다<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span>   tokenString = deviceToken.<span class="built_in">reduce</span>(<span class="string">""</span>, &#123;$<span class="number">0</span> + <span class="type">String</span>(format: <span class="string">"%02X"</span>, $<span class="number">1</span>)&#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"deviceToken: <span class="subst">\(tokenString)</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>시뮬레이터에서는 다르게 동작할 수 있습니다. 정확한 테스트를 위해 실제 디바이스에서 진행해주세요.</code></p><p>device token을 확인하기 위해 console에 tokenString을 출력하도록 해봅니다.</p><p><img src="../../../../images/push-cert/12.png" alt=""><br>앱을 실행하고 Push 권한을 허용하면 콘솔창에 위와 같은 로그가 찍힙니다.</p><h2 id="APN-Easy-Provider"><a href="#APN-Easy-Provider" class="headerlink" title="APN Easy Provider"></a>APN Easy Provider</h2><p>이제 Push 테스트를 진행합니다. AppStore에서 <code>APN easy Provider</code>를 설치해줍니다.</p><p><img src="../../../../images/push-cert/13.png" alt=""><br>이렇게 생겼습니다.</p><p><img src="../../../../images/push-cert/14.png" alt=""><br><code>Add Tokens..</code> 버튼을 눌러 전 단계에서 얻었던 Device Token을 등록합니다.</p><p><img src="../../../../images/push-cert/15.png" alt=""><br>Device Token 입력 후 <code>Confirm</code>을 선택합니다. Name은 아무거나 등록해주세요.</p><p>다음은 <code>2.Choose Certificate File</code> 을 클릭합니다. 여기서는 애플 개발자센터에서 생성한 Push Certificate를 등록해야합니다.<br>애플 개발자센터에서 다운받은 Push Certificate 파일을 더블클릭하면  <code>키체인 접근</code>에 등록이 됩니다.</p><p><img src="../../../../images/push-cert/16.png" alt=""><br>인증서를 오른쪽 버튼으로 클릭 후 <code>~~~ 내보내기</code>를 선택합니다. 파일 확장자를 <code>.cer</code>로 하여 편한 위치에 내보냅니다.</p><p>이제 다시 APN Easy Provider에서 방금 내보내기로 만든 .cer 형태의 Push certificate를 선택합니다.</p><p>그리고 <code>3. Connect to:</code>를 클릭합니다. 우측의 드랍다운메뉴는 <code>gateway.sandbox.push.apple.com</code>을 선택합니다.</p><p><img src="../../../../images/push-cert/17.png" alt=""><br>apple의 apn server에 연결되면 Status에</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connecting to gateway.sandbox.push.apple.com</span><br><span class="line">Connected to server, validating identity...</span><br><span class="line">Connected to APN server successfully</span><br></pre></td></tr></table></figure><p>라고 뜹니다. 이제 Push 테스트 환경 구축이 끝났습니다.</p><p><img src="../../../../images/push-cert/18.png" alt=""></p><p>Push Noti의 타이틀과 내용을 작성 후 <code>5. Send APN</code> 버튼을 눌러봅니다.</p><p><img src="../../../../images/push-cert/19.png" alt=""></p><p>쨘!</p><h2 id="실제-프로젝트에-적용하려면"><a href="#실제-프로젝트에-적용하려면" class="headerlink" title="실제 프로젝트에 적용하려면"></a>실제 프로젝트에 적용하려면</h2><p>위 과정은 앱에 Push기능을 넣고 제대로 동작하는지 과정일 뿐입니다.<br>실제 프로젝트에서 Push를 적용하기 위해서는 앱들의 디바이스 토큰을 관리하고 푸시를 발생시킬 서버를 필요로 합니다.<br>서비스의 로직에 따라 적절한 타이밍에 적절한 Push Noti를 발생시키는 것은 이제 서비스의 역할입니다.</p><p>다음포스트에서는 Firebase를 활용하여 프로젝트에서 Push를 활용하는 방법을 소개합니다.</p>]]></content>
    
    <summary type="html">
    
      푸시 인증서 발급받기
iOS에서 Push 기능을 사용하기 위해서 Push Certificate, 푸시 인증서가 필요합니다. 푸시 인증서를 발급받는 방법은 개발 인증서 발급과정과 비슷합니다.

Apple Developers

애플 개발자센터에 로그인합니다.

+ 버튼을 눌러줍니다.


개발용 인증서 발급페이지와 동일합니다. 빨간색으로 표시한 부분이 Push 인증서입니다.
개발용 인증서와 마찬가지로 Development(개발용)와 Production(앱스토어용) 으로 분리되어 있으며 필요에 따라 생성하면 됩니다.
우선 Developme
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Content Mode : Scale to Fill, Aspect Fit, Aspect Fill 차이 정리</title>
    <link href="http://monibu1548.github.io/2018/05/21/scalemode/"/>
    <id>http://monibu1548.github.io/2018/05/21/scalemode/</id>
    <published>2018-05-21T13:50:52.000Z</published>
    <updated>2018-05-29T12:05:31.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scale-To-Fill-기본값"><a href="#Scale-To-Fill-기본값" class="headerlink" title="Scale To Fill (기본값)"></a>Scale To Fill (기본값)</h2><p><img src="../../../../images/scale/1.png" alt=""></p><ul><li>비율 무시! 귀여운 고양이가 옆으로 퍼져버렸습니다.</li><li>ImageView의 Width와 height에 이미지를 늘리고 우겨넣습니다.</li><li>디자인 가이드로 정해진 레이아웃과 이미지가 아니면 이렇게 이미지를 괴롭히면 안돼요.</li></ul><h2 id="Aspect-To-Fit"><a href="#Aspect-To-Fit" class="headerlink" title="Aspect To Fit"></a>Aspect To Fit</h2><p><img src="../../../../images/scale/2.png" alt=""></p><ul><li>비율 유지! 원본의 비율을 그대로 유지합니다.</li><li>이미지는 <code>절대</code> ImageView 밖으로 나가지 않습니다.</li><li>ImageView 내부에서 밖으로 나가지 않는 선에서 최대치의 값을 갖습니다.</li><li>비율이 맞지 않는경우 내부에 <code>여백</code> 이 생기게 됩니다.</li></ul><h2 id="Aspect-To-Fill"><a href="#Aspect-To-Fill" class="headerlink" title="Aspect To Fill"></a>Aspect To Fill</h2><p><img src="../../../../images/scale/3.png" alt=""></p><ul><li>비율 유지! 원본의 비율을 그대로 유지합니다… 만 이미지가 짤리죠</li><li>위 사진에서 짤리는 부분이 없어보이지만 자세히 보면 이미지가 ImageView 영역 밖으로 나갔음을 알 수 있습니다. (Clip to Bounds) 값을 YES로 하면 짤려서 나오지 않습니다.</li><li>ImageView의 내부에 <code>여백</code>이 절대 생기지 않습니다.</li><li>대신 이미지의 일부가 짤려보일 수 있으므로 인물, 동물 사진에는 적합하지 않을 수 있습니다.</li></ul>]]></content>
    
    <summary type="html">
    
      Scale To Fill (기본값)


 * 비율 무시! 귀여운 고양이가 옆으로 퍼져버렸습니다.
 * ImageView의 Width와 height에 이미지를 늘리고 우겨넣습니다.
 * 디자인 가이드로 정해진 레이아웃과 이미지가 아니면 이렇게 이미지를 괴롭히면 안돼요.

Aspect To Fit


 * 비율 유지! 원본의 비율을 그대로 유지합니다.
 * 이미지는 절대 ImageView 밖으로 나가지 않습니다.
 * ImageView 내부에서 밖으로 나가지 않는 선에서 최대치의 값을 갖습니다.
 * 비율이 맞지 않는경우 내부에 여백 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 앱 업데이트 (강제 업데이트, 선택 업데이트) 기능 구현 예제</title>
    <link href="http://monibu1548.github.io/2018/05/19/remote-config-forced-update/"/>
    <id>http://monibu1548.github.io/2018/05/19/remote-config-forced-update/</id>
    <published>2018-05-18T16:08:15.000Z</published>
    <updated>2018-05-29T12:05:16.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="사용자에게-앱-업데이트-안내하기"><a href="#사용자에게-앱-업데이트-안내하기" class="headerlink" title="사용자에게 앱 업데이트 안내하기"></a>사용자에게 앱 업데이트 안내하기</h2><p>새로운 버전의 앱이 출시되면 AppStore에 등록되고, <code>설정 -&gt; Apple ID -&gt; iTunes 및 App Store -&gt; 자동 다운로드(업데이트)</code> 가 켜져있다면 보통 새벽시간에 자동 업데이트가 됩니다.<br>하지만 사용자가 자동 업데이트 기능을 꺼두었다면?</p><p>새로운 앱 버전의 출시를 알 수 없습니다.</p><p>가장 큰 문제는, 기존 배포버전에 치명적인 버그가 있을때 Hot-fix 배포를 하더라도 자동업데이트 옵션 미사용 사용자들에게는 새로운 버전을 안내할 수 없다는 것 입니다.</p><p>그래서 앱 개발 초기단계에 업데이트 안내 관련 코드를 넣는것이 필수라고 생각합니다.</p><h2 id="업데이트의-구분"><a href="#업데이트의-구분" class="headerlink" title="업데이트의 구분"></a>업데이트의 구분</h2><p>업데이트의 종류는 보통 <code>강제업데이트</code>, <code>선택업데이트</code> 2가지로 나뉩니다.</p><p><code>강제 업데이트</code> 란 앱이 새로운 버전으로 올라가면서 기존 앱과 호환이 불가하거나, 치명적인 버그가 있어 기존 앱의 이용자를 모두 <code>필수적으로</code> 새로운 버전의 앱을 사용하도록 할 때 사용합니다. 앱 실행시 강제 업데이트가 필요한지의 여부를 판단 후, 강제 업데이트가 필요하다면 앱 진입을 막고 앱스토어로 연결하여 업데이트를 할 수 있도록 안내합니다. 이 방법을 사용하면 기존 앱은 전혀 사용할 수 없게 되어, 기존 사용자들의 사용성은 떨어지게 되므로 꼭 사용해야하는 경우가 아니면 <code>선택 업데이트</code> 사용을 권장합니다.</p><p><code>선택 업데이트</code> 란 앱이 새로운 버전으로 올라가지만 큰 변화가 없어서, 기존 앱과 호환이 가능하여 새로운 업데이트가 있다고만 안내합니다.</p><h2 id="업데이트-안내-로직"><a href="#업데이트-안내-로직" class="headerlink" title="업데이트 안내 로직"></a>업데이트 안내 로직</h2><ul><li><p>사용자가 앱을 실행 or 백그라운드에서 포어그라운드로 진입</p></li><li><p>서버에서 <code>앱 최소 지원 버전</code>, <code>최신 앱 버전</code> 을 내려받아 현재 앱의 버전과 비교합니다.</p></li><li><p><code>현재 앱의 버전</code> &lt; <code>앱 최소 지원 버전</code>  =&gt;  강제 업데이트 로직으로 분기</p></li><li><p><code>현재 앱의 버전</code> &lt; <code>최신 앱 버전</code>  =&gt; 선택 업데이트 로직으로 분기</p></li></ul><h2 id="앱의-최소-최신-버전-관리"><a href="#앱의-최소-최신-버전-관리" class="headerlink" title="앱의 최소, 최신 버전 관리"></a>앱의 최소, 최신 버전 관리</h2><p>필수 또는 선택 업데이트의 필요 유무를 판단하기 위해서는 <code>앱 최소지원 버전</code>, <code>최신 앱 버전</code>을 알 수 있어야 합니다. 이 정보를 위해 서버가 필요한가 싶은 이때!<br>우리에겐 <code>Firebase</code>가 있습니다.</p><p>지난 포스팅 <a href="http://monibu1548.github.io/2018/05/14/firebase-config/">iOS앱 고도화 - Firebase Remote Config를 사용한 앱 운영방법</a> 을 참고해주세요.</p><p>Firebase Remote Config에 앱의 버전정보를 등록하여 사용할 수 있습니다.</p><h2 id="앱-실행시-버전체크-예제"><a href="#앱-실행시-버전체크-예제" class="headerlink" title="앱 실행시 버전체크 예제"></a>앱 실행시 버전체크 예제</h2><h3 id="AppDelegate-m"><a href="#AppDelegate-m" class="headerlink" title="AppDelegate.m"></a>AppDelegate.m</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.window?.rootViewController = <span class="type">UIStoryboard</span>.<span class="keyword">init</span>(name: <span class="string">"LaunchScreen"</span>, bundle: <span class="literal">nil</span>).instantiateInitialViewController()</span><br><span class="line">    <span class="type">RemoteConfigManager</span>.sharedManager.launching(completionHandler: &#123; (config) <span class="keyword">in</span>      </span><br><span class="line">    &#125;, forceUpdate: &#123; (forceUpdate) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> !forceUpdate &#123;</span><br><span class="line">            <span class="keyword">let</span> vc = <span class="type">UIStoryboard</span>.<span class="keyword">init</span>(name: <span class="string">"Home"</span>, bundle: <span class="literal">nil</span>).instantiateInitialViewController()</span><br><span class="line">            <span class="keyword">self</span>.window?.rootViewController = vc</span><br><span class="line">            <span class="keyword">self</span>.window?.makeKeyAndVisible()</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppDelegate.m의 didFinishLaunchingWithOptions 메소드입니다.<br>앱 진입 시점에서 window의 rootViewController를 <code>LaunchScreen</code>으로 바꿔치기합니다. 앱 버전을 확인하지 않고 바로 앱으로 진입하는 것을 막기 위함입니다.<br>그 이후 RemoteConfigManager에서 firebase의 remote config를 가져오는 메소드를 호출합니다.<br>RemoteConfigManger의 코드입니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Firebase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastestVersion: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> minVersion: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteConfigManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">RemoteConfigManager</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">launching</span><span class="params">(completionHandler: @escaping <span class="params">(<span class="number">_</span> conf: AppConfig)</span></span></span> -&gt; (), forceUpdate:@escaping (<span class="number">_</span> need: <span class="type">Bool</span>)-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">let</span> remoteConfig = <span class="type">RemoteConfig</span>.remoteConfig()</span><br><span class="line">        </span><br><span class="line">        remoteConfig.fetch(withExpirationDuration: <span class="type">TimeInterval</span>(<span class="number">3600</span>)) &#123; (status, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> status == .success &#123;</span><br><span class="line">                remoteConfig.activateFetched()</span><br><span class="line">          </span><br><span class="line">                <span class="comment">// 데이터 Fetch</span></span><br><span class="line">                <span class="keyword">let</span> appConfig: <span class="type">AppConfig</span> = <span class="type">AppConfig</span>()</span><br><span class="line">                appConfig.lastestVersion = remoteConfig[<span class="string">"lastest_version"</span>].stringValue</span><br><span class="line">                appConfig.minVersion = remoteConfig[<span class="string">"min_version"</span>].stringValue</span><br><span class="line"></span><br><span class="line">                completionHandler(appConfig)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 강제업데이트</span></span><br><span class="line">                <span class="keyword">let</span> needForcedUpdate:<span class="type">Bool</span> = (<span class="keyword">self</span>.compareVersion(versionA: <span class="type">ConfigEnv</span>.appVersion(), versionB: appConfig.minVersion) == <span class="type">ComparisonResult</span>.orderedAscending)</span><br><span class="line">                forceUpdate(needForcedUpdate)</span><br><span class="line">                <span class="keyword">if</span> needForcedUpdate &#123;</span><br><span class="line">                    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, message: <span class="string">"필수 업데이트가 있습니다. 업데이트하시겠습니까?"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</span><br><span class="line">                    alertController.addAction(<span class="type">UIAlertAction</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: &#123; (action) <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">// 앱스토어마켓으로 이동</span></span><br><span class="line">                    &#125;))</span><br><span class="line">                    <span class="keyword">var</span> topController = <span class="type">UIApplication</span>.shared.keyWindow?.rootViewController</span><br><span class="line">                    <span class="keyword">if</span> topController != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> <span class="keyword">let</span> presentedViewController = topController?.presentedViewController &#123;</span><br><span class="line">                            topController = presentedViewController</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    topController!.present(alertController, animated: <span class="literal">false</span>, completion: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 선택업데이트</span></span><br><span class="line">                <span class="keyword">let</span> needUpdate:<span class="type">Bool</span> = (<span class="keyword">self</span>.compareVersion(versionA: <span class="type">ConfigEnv</span>.appVersion(), versionB: appConfig.minVersion) != <span class="type">ComparisonResult</span>.orderedAscending) &amp;&amp; (<span class="keyword">self</span>.compareVersion(versionA: <span class="type">ConfigEnv</span>.appVersion(), versionB: appConfig.lastestVersion) == <span class="type">ComparisonResult</span>.orderedAscending)</span><br><span class="line">                <span class="keyword">if</span> needUpdate &#123;</span><br><span class="line">                    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, message: <span class="string">"최신 업데이트가 있습니다. 업데이트하시겠습니까?"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</span><br><span class="line">                    alertController.addAction(<span class="type">UIAlertAction</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: &#123; (action) <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">// 앱스토어마켓으로 이동</span></span><br><span class="line">                    &#125;))</span><br><span class="line">                    alertController.addAction(<span class="type">UIAlertAction</span>.<span class="keyword">init</span>(title: <span class="string">"나중에"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: &#123; (action) <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">// 앱으로 진입</span></span><br><span class="line">                    &#125;))</span><br><span class="line">                    <span class="keyword">var</span> topController = <span class="type">UIApplication</span>.shared.keyWindow?.rootViewController</span><br><span class="line">                    <span class="keyword">if</span> topController != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> <span class="keyword">let</span> presentedViewController = topController?.presentedViewController &#123;</span><br><span class="line">                            topController = presentedViewController</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    topController!.present(alertController, animated: <span class="literal">false</span>, completion: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">compareVersion</span><span class="params">(versionA:String!, versionB:String!)</span></span> -&gt; <span class="type">ComparisonResult</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> majorA = <span class="type">Int</span>(<span class="type">Array</span>(versionA.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">0</span>])!</span><br><span class="line">        <span class="keyword">let</span> majorB = <span class="type">Int</span>(<span class="type">Array</span>(versionB.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">0</span>])!</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> majorA &gt; majorB &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedDescending</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> majorB &gt; majorA &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedAscending</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> minorA = <span class="type">Int</span>(<span class="type">Array</span>(versionA.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">1</span>])!</span><br><span class="line">        <span class="keyword">let</span> minorB = <span class="type">Int</span>(<span class="type">Array</span>(versionB.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">1</span>])!</span><br><span class="line">        <span class="keyword">if</span> minorA &gt; minorB &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedDescending</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> minorB &gt; minorA &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedAscending</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedSame</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Firebase Remote Config에서 데이터를 Fetch 한 뒤에 <code>AppConfig</code> 라는 클래스에 매핑을 합니다. 그 이후 plist에 있는 현재 앱의 버전과 AppConfig의 minVersion, lastestVersion을 비교하여 강제, 선택 업데이트 여부를 판단합니다.<br>AppConfig 클래스의 변수들이 저렇게 생긴 이유는 Firebase에서 이렇게 설정했기 때문입니다.</p><p><img src="../../../../images/update/1.png" alt=""></p><p><code>compareVersion</code>이라는 메소드로 현재버전과 최소, 최신 버전을 확인하여 적절한 AlertController를 노출합니다.</p><h2 id="강제-업데이트-화면"><a href="#강제-업데이트-화면" class="headerlink" title="강제 업데이트 화면"></a>강제 업데이트 화면</h2><p><img src="../../../../images/update/2.png" alt=""></p><p> AlertController의 버튼으로 <code>업데이트</code> 하나만 노출하며, 클릭시 앱스토어 이동하여 업데이트를 안내합니다. 그 외 앱의 진입방법은 없으므로 사용자는 업데이트 없이 기존 앱을 사용할 수 없습니다.</p><h2 id="선택-업데이트-화면"><a href="#선택-업데이트-화면" class="headerlink" title="선택 업데이트 화면"></a>선택 업데이트 화면</h2><p> <img src="../../../../images/update/3.png" alt=""></p><p> AlertController의 버튼으로 <code>업데이트</code>와 <code>나중에</code>를 노출하여, 앱스토어로 이동하여 업데이트를 할지, 그냥 앱으로 진입할지 사용자에게 선택권을 부여합니다.</p><p><code>추가적으로</code></p><p>업데이트를 안 한 경우, 앱을 실행 할때마다 선택 업데이트 Alert이 뜨는데요, 사용자의 불편을 최소화 하기 위해서 <code>7일간 보지않기</code> 등을 추가하는 것이 좋습니다.</p><h2 id="iOS-개발자가-업데이트-로직을-사용할-때-앱의-배포-과정"><a href="#iOS-개발자가-업데이트-로직을-사용할-때-앱의-배포-과정" class="headerlink" title="iOS 개발자가 업데이트 로직을 사용할 때 앱의 배포 과정"></a>iOS 개발자가 업데이트 로직을 사용할 때 앱의 배포 과정</h2><ul><li>앱을 개발하면서 <code>강제 업데이트</code>를 사용할지, <code>선택 업데이트</code>를 사용할지 결정</li></ul><h3 id="선택-업데이트라면"><a href="#선택-업데이트라면" class="headerlink" title="선택 업데이트라면?"></a>선택 업데이트라면?</h3><ul><li>새로운 버전의 앱이 AppStore에 노출됨을 확인하고 Remote Config 설정에서 <code>lastestVersion</code>을 최신버전으로 수정합니다.</li></ul><h3 id="강제-업데이트라면"><a href="#강제-업데이트라면" class="headerlink" title="강제 업데이트라면?"></a>강제 업데이트라면?</h3><ul><li>새로운 버전의 앱이 AppStore에 노출됨을 확인하고 Remote Config 설정에서 <code>minVersion</code>을 최신버전으로 수정합니다. 물론 <code>lastestVersion</code>도 최신으로 수정합니다.</li></ul><ul><li><code>주의사항</code></li></ul><ul><li>앱을 실행할 때 앱의 진입을 막고, remote config의 데이터를 가져오는 로직이 추가됩니다. firebase 서비스에 장애가 생길일은 드물겠지만, 만약 장애가 있다면 앱에 진입이 불가할 수 있습니다.</li><li>firebase remote config 설정이 즉시 적용은 아니고, 조금의 시간이 소요됩니다. (몇분정도?)</li><li>아직 앱스토어에 업데이트된 빌드가 업로드 되지 않은 상태에서, 강제 업데이트를 설정하면 사용자는 앱을 사용할 수 없습니다.</li><li>업데이트 빌드가 앱스토어에 노출되는 시점이 사용자마다 다를 수 있습니다. 어떤 사용자는 앱스토어에 들어가면 <code>업데이트</code>가 바로 뜨지만, 일부 사용자는 <code>열기</code> 버전으로 기존 버전만 사용가능 할 수 있습니다. 이때, 강제 업데이트 걸면 후자의 사람들은 업데이트가 가능해질 때까지 앱을 사용할 수 없습니다.</li><li>위의 이슈는 사용자가 앱스토어의 업데이트 탭에서 새로고침을 하면 수정되긴 합니다.</li></ul>]]></content>
    
    <summary type="html">
    
      사용자에게 앱 업데이트 안내하기
새로운 버전의 앱이 출시되면 AppStore에 등록되고, 설정 -&gt; Apple ID -&gt; iTunes 및 App Store -&gt; 자동 다운로드(업데이트) 가 켜져있다면 보통 새벽시간에 자동 업데이트가 됩니다.
하지만 사용자가 자동 업데이트 기능을 꺼두었다면?

새로운 앱 버전의 출시를 알 수 없습니다.

가장 큰 문제는, 기존 배포버전에 치명적인 버그가 있을때 Hot-fix 배포를 하더라도 자동업데이트 옵션 미사용 사용자들에게는 새로운 버전을 안내할 수 없다는 것 입니다.

그래서 앱 개발 초기단계에
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/tags/Firebase/"/>
    
      <category term="업데이트" scheme="http://monibu1548.github.io/tags/%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/"/>
    
      <category term="RemoteConfig" scheme="http://monibu1548.github.io/tags/RemoteConfig/"/>
    
  </entry>
  
  <entry>
    <title>Google Analytics example(구글 애널리틱스를 이용한 앱 운영)</title>
    <link href="http://monibu1548.github.io/2018/05/17/ga/"/>
    <id>http://monibu1548.github.io/2018/05/17/ga/</id>
    <published>2018-05-17T11:24:56.000Z</published>
    <updated>2019-01-20T04:09:51.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Analytics의-필요성"><a href="#Analytics의-필요성" class="headerlink" title="Analytics의 필요성"></a>Analytics의 필요성</h2><p>iOS앱을 만들어서 많은 사용자를 보유하려면 사용자가 어떤 기능을 좋아하는지(얼마나 많이 사용하는지), 사용하지 않는 기능은 무엇인지(사용률이 적은 기능)이 무엇인지 알고 계속 개선해 나가야 합니다. 하지만 iOS앱은 AppStore에 업로드하면 개발자의 손을 떠나게 됩니다.</p><p>그렇다면 사람들이 어떤 기능을 자주 쓰는지, 필요로 하는지 어떻게 수집을 할까요?<br><code>지표 수집</code>툴을 사용합니다. 대표적으로는 <a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a>가 있습니다. 그 외에도 <a href="https://www.toast.com/" target="_blank" rel="noopener">Toast Analytics</a>, <a href="https://www.userhabit.io/ko" target="_blank" rel="noopener">UserHabbit</a> 등 다른 지표수집 툴도 많이 있습니다</p><p>이번에 Swift 스터디를 하면서 만들었던 앱에 Google Analytics를 연동해보면서 기록을 정리해서 남깁니다.</p><h2 id="Google-Analytics-가입하기"><a href="#Google-Analytics-가입하기" class="headerlink" title="Google Analytics 가입하기"></a>Google Analytics 가입하기</h2><p><a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a> 에 접속후 로그인합니다. 계정은 구글계정으로 사용합니다.</p><p><img src="../../../../images/ga/1.png" alt=""><br>지표수집에 사용할 앱 or 웹을 등록합니다. 기존에 사용하던 앱 2개가 있어서 위와 같은 페이지로 뜨는데, <code>관리</code> 쪽 메뉴에서 새로운 앱을 등록할 수 있습니다. 이름이 <code>계정 만들기</code>로 되어있어요.</p><p><img src="../../../../images/ga/2.png" alt=""><br>iOS 앱의 지표수집에 사용할 것으로 <code>모바일 앱</code>을 선택 후 계정이름과, 앱이름을 설정합니다.<br>데이터 공유 설정은 잘 읽어보시고 선택하시고, 모르겠다 싶으면 전체선택하셔도 괜찮습니다.<br>모두 작성 완료 후 가장 아래에 <code>추적 ID 가져오기</code>를 클릭합니다.</p><p><img src="../../../../images/ga/3.png" alt=""><br>애널리틱스 서비스 약관동의 팝업이 뜹니다. 요즘 GDPR 관련돼서 이슈가 많은데요. GDPR 관련해서는 따로 <code>꼭</code> 확인해주세요.<br>동의함을 눌러주세요.</p><p><img src="../../../../images/ga/4.png" alt=""><br>앱 등록이 완료되면 위와 같은 화면이 나옵니다. 이 화면에서 필요한 것은!! <code>추적 ID</code> 입니다. 복사해두세요~</p><h2 id="iOS에-Google-Analytics-적용하기"><a href="#iOS에-Google-Analytics-적용하기" class="headerlink" title="iOS에 Google Analytics 적용하기"></a>iOS에 Google Analytics 적용하기</h2><h3 id="Pod-install"><a href="#Pod-install" class="headerlink" title="Pod install"></a>Pod install</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;GoogleAnalytics&apos;</span><br></pre></td></tr></table></figure><p>사용중인 프로젝트의 Podfile에 <code>GoogleAnanytics</code> Pod 을 추가, 설치해줍니다.</p><p>cocoaPod사용법은 아래 포스팅을 참고해주세요.<br><a href="http://monibu1548.github.io/2018/04/16/cocoapods/">iOS 프로젝트에 cocoapods 적용하기</a><br><a href="http://monibu1548.github.io/2018/04/16/cocoapods-prompt/">CocoaPods 똑똑하게 사용하기 (명령어, 사용 예시 소개)</a></p><h3 id="AppDelegate-설정"><a href="#AppDelegate-설정" class="headerlink" title="AppDelegate 설정"></a>AppDelegate 설정</h3><p>아쉽게도 아직 <code>Swift</code> 에서는 Object-c bridge를 통해 사용합니다. 번거로워요.<br>object-bridge 는 다음 블로그를 확인해주세요 <a href="https://m.blog.naver.com/PostView.nhn?blogId=seotaji&amp;logNo=220312825002&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F" target="_blank" rel="noopener">애플 스위프트(Apple Swift) Bridging-Header.h 생성하기</a></p><p>그리고 AppDelegate의 didFinishLaunchingWithOptions메소드에 아까 발급받은 Tracking ID(추적 ID)를 등록합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    gai.tracker(withTrackingId: <span class="string">"YOUR_TRACKING_ID"</span>)  <span class="comment">// 발급받은 트래킹 ID를 넣어주세요</span></span><br><span class="line">    <span class="comment">// Optional: automatically report uncaught exceptions.</span></span><br><span class="line">    gai.trackUncaughtExceptions = <span class="literal">true</span>   <span class="comment">// 앱 크래시 발생 내역도 수집을 할 것인지 선택하는 옵션입니다.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Optional: set Logger to VERBOSE for debug information.</span></span><br><span class="line">    <span class="comment">// Remove before app release.</span></span><br><span class="line">    gai.logger.logLevel = .verbose;  <span class="comment">// 로그레벨을 결정합니다. 앱스토어 배포용에서는 이 옵션을 꼭 제거해주세요</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>주의할 점</code></p><ul><li>우리가 원하는 것은 이 앱의 사용자들이 앱을 사용하는 방식에 대한 데이터입니다. 위의 코드를 개발단계에서 사용할 경우 앱을 개발하는 과정에서의 지표도 수집되기 때문에 유효한 데이터를 수집할 수 없습니다.</li><li>유효한 데이터만 수집하기 위해서는 아래의 방식을 따릅니다<ul><li>개발용, 배포용 Analytics를 각각 만들어서 빌드 config에 따라 트래킹 ID를 바꿔치기 합니다.</li><li>사실 개발용은 지표수집의 의미가 없기 때문에 Debug config에서는 트래킹 ID 를 비워도 됩니다.</li></ul></li></ul><h2 id="수집할-지표의-결정"><a href="#수집할-지표의-결정" class="headerlink" title="수집할 지표의 결정"></a>수집할 지표의 결정</h2><p>AppDelegate에 트래킹 ID 등록까지 끝났다면, 사용준비는 끝났습니다. 이제 수집하고 싶은 데이터의 위치에 수집코드만 넣어주면 됩니다.</p><h3 id="화면-정보-수집"><a href="#화면-정보-수집" class="headerlink" title="화면 정보 수집"></a>화면 정보 수집</h3><p>아마 무조건 사용하는 정보일겁니다. 사용자가 어떤 화면에 얼마나 많이, 오래 진입했는지의 정도를 알 수 있는 지표입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        super.viewWillAppear(animated)</span><br><span class="line">        guard let tracker = GAI.sharedInstance().defaultTracker else &#123; return &#125;</span><br><span class="line">        tracker.set(kGAIScreenName, value: &quot;메인&quot;)</span><br><span class="line">        </span><br><span class="line">        guard let builder = GAIDictionaryBuilder.createScreenView() else &#123; return &#125;</span><br><span class="line">        tracker.send(builder.build() as [NSObject : AnyObject])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>화면 정보를 수집할 뷰컨트롤러의 <code>viewWillAppear</code>에 위의 코드를 넣어줍니다.<br><code>tracker.set()</code> 의 value에는 화면 이름을 입력합니다.<br>이제 사용자가 해당 화면에 진입하면 해당 화면정보가 수집됩니다.</p><h3 id="이벤트-정보-수집"><a href="#이벤트-정보-수집" class="headerlink" title="이벤트 정보 수집"></a>이벤트 정보 수집</h3><p>화면 수집 다음으로 유용한 지표입니다. 사용자가 특정 버튼을 얼마나 눌렀는지, 사용빈도를 알 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private func getVoca() -&gt; Voca? &#123;</span><br><span class="line">        </span><br><span class="line">        let tracker = GAI.sharedInstance().defaultTracker</span><br><span class="line">        tracker?.send(GAIDictionaryBuilder.createEvent(withCategory: &quot;단어 퀴즈&quot;, action: &quot;문제 Go&quot;, label: &quot;문제 출제&quot;, value: nil).build() as [NSObject : AnyObject])</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        // ... 문제 출제 로직 ... </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>위 코드는 특정 버튼을 눌렀을때 해당 이벤트를 수집하는 코드입니다. 카테고리, 액션, 라벨 3단계로 구분되어 개발자가 서비스에 맞게 사용하면 됩니다.</p><p><img src="../../../../images/ga/5.png" alt=""><br><img src="../../../../images/ga/6.png" alt=""></p><p>테스트를 해보면 다음과 같은 화면이 뜹니다. 현재 실시간 사용자, 화면, 앱버전, 위치 등 다양한 정보를 볼 수 있습니다!</p>]]></content>
    
    <summary type="html">
    
      Analytics의 필요성
iOS앱을 만들어서 많은 사용자를 보유하려면 사용자가 어떤 기능을 좋아하는지(얼마나 많이 사용하는지), 사용하지 않는 기능은 무엇인지(사용률이 적은 기능)이 무엇인지 알고 계속 개선해 나가야 합니다. 하지만 iOS앱은 AppStore에 업로드하면 개발자의 손을 떠나게 됩니다.

그렇다면 사람들이 어떤 기능을 자주 쓰는지, 필요로 하는지 어떻게 수집을 할까요?
지표 수집툴을 사용합니다. 대표적으로는 Google Analytics가 있습니다. 그 외에도 Toast Analytics, UserHabbit 등 다
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/categories/iOS/Firebase/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="구글 애널리틱스" scheme="http://monibu1548.github.io/tags/%EA%B5%AC%EA%B8%80-%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B1%EC%8A%A4/"/>
    
      <category term="지표수집" scheme="http://monibu1548.github.io/tags/%EC%A7%80%ED%91%9C%EC%88%98%EC%A7%91/"/>
    
  </entry>
  
</feed>
