<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JingyuJung&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://monibu1548.github.io/"/>
  <updated>2018-10-13T13:44:40.673Z</updated>
  <id>http://monibu1548.github.io/</id>
  
  <author>
    <name>Jingyu Jung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[RxSwift] 2일차, RxSwift에서 지원하는 Subject에 대한 이해</title>
    <link href="http://monibu1548.github.io/2018/10/13/rxswift-subject/"/>
    <id>http://monibu1548.github.io/2018/10/13/rxswift-subject/</id>
    <published>2018-10-13T13:43:13.000Z</published>
    <updated>2018-10-13T13:44:40.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>Subject는 Observable과 Observer 두가지 역할을 한다. 즉, onNext() 메소드를 통해서 Event를 발생시키는 Observable의 역할과, subscribe 메소드를 통해 Event Sequence에서 Event를 구독하여 처리할 수 있는 Observer의 역할을 모두 수행할 수 있다.</p><p>RxSwift에서는 4가지 종류의 Subject를 지원한다.</p><ul><li>PublishSubject</li><li>BehaviorSubject</li><li>ReplySubject</li><li>Variables (Deprecated 예정)</li></ul><h2 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h2><p>가장 일반적인 Subject이다. Observable의 특징대로 subscribe 되면 event sequence에서 event를 받으며 terminated(error 또는 completed)가 되면 더이상 event를 수신하지 않는다.</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// completed</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"G"</span>)</span><br><span class="line">subject.onNext(<span class="string">"H"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br><span class="line">completed</span><br><span class="line">disposed</span><br></pre></td></tr></table></figure><p>PublishSubject가 생성되고 A, B, C… 의 event sequence를 갖는다고 할 때,<br>observer1은 “C” event 이후에 구독을 시작한다.</p><p>따라서 <code>D</code> Event 부터 수신하며 Completed Event를 수신한 이후에는 더이상 G, H는 수신하지 않는다.</p><h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>Behavior Subject의 가장 큰 특징은 initial Value를 갖는다는 것이다. 따라서 Behavior Subject를 생성시에는 반드시 초기값을 입력해야한다.<br>Observer측면에서 보면 구독과 동시에 initial Event를 수신한다. initial Event는 가장 최근에 발생한 Event를 의미한다.<br>Subject가 처음 생성되었다면 생성시 입력된 initial value를, event sequence 중간에 subscribe했다면 가장 최근의 event를 수신한다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"Initial Value"</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// completed</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"G"</span>)</span><br><span class="line">subject.onNext(<span class="string">"H"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">C</span></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br><span class="line">completed</span><br><span class="line">disposed</span><br></pre></td></tr></table></figure><p>PublishSubject 예제에서 PublishSubject를 BehaviorSubject로 변경 후의 결과이다.<br>observer1이 subscribe를 하면서 가장 최근에 발생한 Event <code>C</code>를 가져온다는 차이점이 있다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"Initial Value"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">Initial</span> <span class="type">Value</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br></pre></td></tr></table></figure><h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>ReplaySubject는 Buffer를 갖는다. Buffer에 Event를 Queue로 저장하며 subscribe 하면 buffer에 있는 event sequence 부터 수신하기 시작한다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br></pre></td></tr></table></figure><p>Buffer를 2로 ReplaySubject를 생성한 후 subscribe한 결과이다. 가장 최근에 발생한 B, C 를 크기가 2인 Buffer에 저장하고 있다가 subscribe가 되면 Event를 전달한다.</p><p>Buffer크기보다 이전에 발생했던 이벤트 갯수가 적으면 어떻게 될까?</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line"><span class="type">D</span></span><br><span class="line"><span class="type">E</span></span><br><span class="line"><span class="type">F</span></span><br></pre></td></tr></table></figure><p>Buffer가 가득차지 않았을 뿐, Buffer에 있는 Event들을 순서대로 구독하는데 문제가 없다.</p><p>그렇다면 subscribe 이전에 onCompleted가 발생한 경우에는 어떻게 될까?</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A"</span>)</span><br><span class="line">subject.onNext(<span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// onCompleted</span></span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 구독 시작</span></span><br><span class="line"><span class="keyword">let</span> observer1 = subject.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"disposed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"D"</span>)</span><br><span class="line">subject.onNext(<span class="string">"E"</span>)</span><br><span class="line">subject.onNext(<span class="string">"F"</span>)</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line">completed</span><br><span class="line">disposed</span><br></pre></td></tr></table></figure><p>onCompleted 발생 이전의 Event들은 Buffer에 그대로 유지되며 onCompleted 까지 Event Sequence가 전달된다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>Variables를 제외한 3가지 타입(Publish, Behavior, Replay)의 Subject에 대해 예제를 통해 학습했다.<br>각각의 Subject는 Event Sequence에 대한 처리시점에 따라 구분되어 있으며, 실제 프로젝트에 적용할 때 적절한 선택이 필요해 보인다!</p>]]></content>
    
    <summary type="html">
    
      Subject
Subject는 Observable과 Observer 두가지 역할을 한다. 즉, onNext() 메소드를 통해서 Event를 발생시키는 Observable의 역할과, subscribe 메소드를 통해 Event Sequence에서 Event를 구독하여 처리할 수 있는 Observer의 역할을 모두 수행할 수 있다.

RxSwift에서는 4가지 종류의 Subject를 지원한다.

 * PublishSubject
 * BehaviorSubject
 * ReplySubject
 * Variables (Deprecated 예정
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/categories/iOS/RxSwift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>[RxSwift] 1일차, RxSwift란, Observable에 대한 이해</title>
    <link href="http://monibu1548.github.io/2018/10/11/rxswift-observable/"/>
    <id>http://monibu1548.github.io/2018/10/11/rxswift-observable/</id>
    <published>2018-10-11T12:18:51.000Z</published>
    <updated>2018-10-11T12:48:13.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h1><p>정의 : Observable Sequense와 함수형 operator를 이용한 이벤트 기반의 비동기 프로그래밍 라이브러리.</p><h3 id="참고-iOS-SDK에서-지원하는-비동기-프로그래밍"><a href="#참고-iOS-SDK에서-지원하는-비동기-프로그래밍" class="headerlink" title="참고) iOS SDK에서 지원하는 비동기 프로그래밍"></a>참고) iOS SDK에서 지원하는 비동기 프로그래밍</h3><ol><li>NotificationCenter</li><li>Delegate Pattern</li><li>GCD (Grand Central Dispatch)</li><li>Closure</li></ol><h2 id="Rx를-시작하기-전에-해야-할-용어정리"><a href="#Rx를-시작하기-전에-해야-할-용어정리" class="headerlink" title="Rx를 시작하기 전에 해야 할 용어정리"></a>Rx를 시작하기 전에 해야 할 용어정리</h2><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>DataType에 대한 변하지 않는 상태값의 이벤트를 만들어 전달 할 수 있는 능력(프로토콜)</p><p>실제 RxSwift 라이브러리 코드를 뜯어보면,</p><p>ObservableConvertibleType (최상위 프로토콜)<br>ObservableType<br>Observable (하위 프로토콜의 최종 구현체) 로 구성되며</p><p>데이터타입이 Observable할 수 있도록 프로토콜을 통해 구현하게 한다.</p><p>Observable의 LifeCycle을 살펴보면</p><ol><li>next 이벤트를 던진다, terminated 되기 전까지.</li><li>completed or Error를 던지면 terminated된다.</li><li>terminated 되면 더이상 이벤트를 던지지 않는다.</li></ol><p>여기에서 Event란, 인스턴스가 변화하는 상태값을 의미한다. 각각의 상태값은 Observable 이벤트가 흘러가는 동안 immutable 속성을 갖는다.</p><p>이벤트의 흐름을 Observable Sequense라고 하며, 보통 Marvel diagram으로 시각화한다.</p><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>Swift에서 기본적으로 제공하는 Array의 filter, map, reduce와 같은 맥락의 커스텀 메소드라고 생각하면 된다.<br>Observable도 결국 Event 흐름 Array로 각 로직에 맞는 커스텀 Operator를 작성해야 한다.<br>각각의 Operator는 Input, Output이 명확하게 설계하여 사이드이펙트를 줄이고 단위테스트를 용이하게 할 수 있다.</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>RxSwift라이브러리에서 Dispatch Queue의 역할을 하는 개념.<br>결국 Observable을 통해 이벤트를 수신할 수 있도록 하는 스타터.</p><p>Scheduler는 커스텀 없이 RxSwift에서 제공하는 기능만으로도 99%를 커버할 수 있다고 한다.</p><h1 id="RxSwift-실습"><a href="#RxSwift-실습" class="headerlink" title="RxSwift 실습"></a>RxSwift 실습</h1><ul><li>실습에 필요한 환경 : XCode, CocoaPod</li></ul><ol><li>Swift Project를 생성 후 pod init을 통해 Podfile생성</li><li>Podfile에 pod ‘RxSwift’ 추가 후 pod install</li><li>xcworkspace 실행. 빌드.</li><li>프로젝트 내에 playground 파일 생성 후 RxSwift import</li></ol><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>1.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p>range 메소드는 start, count 내의 Event Sequence를 만든다</p><ol start="2"><li><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure></li></ol><p>of 메소드에 sequence를 넘기면 순서대로 Event Sequence가 생성된다.</p><p>3.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.of([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>])</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>]</span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p>of 메소드에 배열을 넘길 경우 배열 그 자체에 대한 Event가 생성된다.</p><p>4.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.from([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>])</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completed"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="type">A</span></span><br><span class="line"><span class="type">B</span></span><br><span class="line"><span class="type">C</span></span><br><span class="line">completed</span><br></pre></td></tr></table></figure><p>from 메소드를 사용하면 배열 객체의 각 element에 대한 event sequence가 생성된다.</p><h2 id="실제-프로젝트-개발에서의-적용"><a href="#실제-프로젝트-개발에서의-적용" class="headerlink" title="실제 프로젝트 개발에서의 적용"></a>실제 프로젝트 개발에서의 적용</h2><p>위의 예제는 정적인 배열 또는 클래스에 대한 Event 생성으로, 학습용일뿐 실제 프로젝트에는 적용할 수 없다.<br>실제 프로젝트에 적용하기 위해서는 Runtime에 외부 요건(네트워크 통신, 사용자의 입력)에 대한 Event Sequence를 사용해야한다.</p><p>Rx에 대한 이해를 바탕을 Observable한 사용자 클래스, 적절한 Operator를 이용해 적용한다.</p>]]></content>
    
    <summary type="html">
    
      RxSwift
정의 : Observable Sequense와 함수형 operator를 이용한 이벤트 기반의 비동기 프로그래밍 라이브러리.

참고) iOS SDK에서 지원하는 비동기 프로그래밍
 1. NotificationCenter
 2. Delegate Pattern
 3. GCD (Grand Central Dispatch)
 4. Closure

Rx를 시작하기 전에 해야 할 용어정리
Observable
DataType에 대한 변하지 않는 상태값의 이벤트를 만들어 전달 할 수 있는 능력(프로토콜)

실제 RxSwift 라이브러리
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/categories/iOS/RxSwift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://monibu1548.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>[iOS] In-App-Purchase 인앱구매 적용기</title>
    <link href="http://monibu1548.github.io/2018/08/29/iap/"/>
    <id>http://monibu1548.github.io/2018/08/29/iap/</id>
    <published>2018-08-29T12:44:16.000Z</published>
    <updated>2018-08-29T13:06:05.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="수익을-내보자"><a href="#수익을-내보자" class="headerlink" title="수익을 내보자"></a>수익을 내보자</h1><p>지금까지는 AdMob을 통해 광고 수익을 소소하게 벌고 있었는데요. 이번엔 인앱구매를 통해 수익모델을 붙여보려고 합니다.<br>보통 주로 무료앱에서는 광고 제거 버전을 인앱구매 상품으로 판매중입니다.</p><p>저도 한번 인앱구매로 광고제거 버전을 만들어 보려고 합니다.</p><h2 id="앱-설정-변경하기"><a href="#앱-설정-변경하기" class="headerlink" title="앱 설정 변경하기"></a>앱 설정 변경하기</h2><p>지금까지 Push 등 앱에 특별한 기능을 추가하기 위해서는 애플 개발자 센터에서 옵션 설정을 해왔습니다.<br>인앱구매도 마찬가지로 <a href="https://developer.apple.com/" target="_blank" rel="noopener">애플 개발자 센터</a>에서 인앱구매 기능을 사용하겠다고 설정해야합니다.</p><p><img src="../../../../images/iap/1.png" alt=""></p><p>앱의 설정을 변경하기 위해 애플 개발자 센터에서 앱 설정 페이지로 들어갑니다.</p><p><img src="../../../../images/iap/2.png" alt=""></p><p>In-App Purchase 를 Enable로 만들어줍니다! 저는 왜때문인지 이미 되어있네요…</p><h2 id="상품-등록하기"><a href="#상품-등록하기" class="headerlink" title="상품 등록하기"></a>상품 등록하기</h2><p>이제 앱에서 판매할 상품을 등록해야합니다. 상품 등록은 애플 개발자 센터가 아닌 <a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">아이튠스커넥트</a>에서 진행합니다.</p><p><img src="../../../../images/iap/3.png" alt=""></p><p>상품을 판매할 앱의 상세 페이지에서 <code>앱 내 추가기능</code> 탭을 선택합니다.</p><ul><li>버튼을 눌러봅니다.</li></ul><p><img src="../../../../images/iap/4.png" alt=""></p><p>판매할 제품의 속성을 선택합니다.</p><ul><li>소모품 : 말 그대로 소모품입니다. 유저가 필요할 때마다 구입하는 제품입니다.</li><li>비소모품 : 한번 구매하면 아이튠즈 기록을 통해 복원이 가능한 계정에 종속되는 제품입니다.</li><li>비자동 갱신구독 : 기간 제한을 둔 제품을 판매합니다. 유저는 기한이 끝나면 재구매 가능합니다.</li></ul><p>이번 앱에서는 구매를 통해 광고제거 기능확장을 제공할 예정입니다. <code>비소모품</code>을 선택합니다.</p><p><img src="../../../../images/iap/5.png" alt=""></p><p>가격 정보 등 판매할 제품의 정보를 입력합니다.<br>심사 정보는 나중에 기입합니다.</p><h2 id="앱에-기능-구현하기"><a href="#앱에-기능-구현하기" class="headerlink" title="앱에 기능 구현하기"></a>앱에 기능 구현하기</h2>]]></content>
    
    <summary type="html">
    
      수익을 내보자
지금까지는 AdMob을 통해 광고 수익을 소소하게 벌고 있었는데요. 이번엔 인앱구매를 통해 수익모델을 붙여보려고 합니다.
보통 주로 무료앱에서는 광고 제거 버전을 인앱구매 상품으로 판매중입니다.

저도 한번 인앱구매로 광고제거 버전을 만들어 보려고 합니다.

앱 설정 변경하기
지금까지 Push 등 앱에 특별한 기능을 추가하기 위해서는 애플 개발자 센터에서 옵션 설정을 해왔습니다.
인앱구매도 마찬가지로 애플 개발자 센터에서 인앱구매 기능을 사용하겠다고 설정해야합니다.



앱의 설정을 변경하기 위해 애플 개발자 센터에서
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>[iOS] AppDelegate의 역할과 메소드</title>
    <link href="http://monibu1548.github.io/2018/08/28/appdelegate/"/>
    <id>http://monibu1548.github.io/2018/08/28/appdelegate/</id>
    <published>2018-08-28T12:31:47.000Z</published>
    <updated>2018-08-28T13:44:56.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AppDelegate-의-역할"><a href="#AppDelegate-의-역할" class="headerlink" title="AppDelegate 의 역할"></a>AppDelegate 의 역할</h1><p>UITableViewDelegate를 구현하다 =&gt; UITableView에서 필요한 기능을 대신 구현하다<br>라는 느낌으로 AppDelegate는 App( Application ) 이 해야할 일을 대신 구현한다는 의미입니다.</p><p>여기에서 App이 해야할 일이란, Background 진입, Foreground 진입, 외부에서의 요청 (apns) 등을 말합니다.</p><h3 id="UIApplicationMain-은-뭘까요"><a href="#UIApplicationMain-은-뭘까요" class="headerlink" title="@UIApplicationMain 은 뭘까요?"></a>@UIApplicationMain 은 뭘까요?</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span></span></span><br></pre></td></tr></table></figure><p>지워보면 알겠죠. 주석처리 해봅니다. 네 에러가 나죠.<br><img src="../../../../images/appdelegate/1.png" alt=""></p><p>실제로 앱은 UIApplication이라는 객체로 추상화 되어 Run Loop를 통해 프로그램 코드를 실행합니다. 개발자는 AppDelegate를 통해 UIApplication의 역할의 일부를 위임받아 UI를 그리면서 앱 다운 앱이 탄생합니다.</p><p>여기서 의문.</p><p>UIApplication은 AppDelegate.m 파일에 있는 AppDelegate 클래스가 본인의 역할을 위임받은 클래스인지 어떻게 알까요?</p><p>보통 <code>tableView.delegate = {UITableViewDelegate를 구현한 객체}</code> 이런식으로 Delegate를 연결하죠.<br>그런데 앱을 실행할 때,,, UIApplication객체를 가져와서 delegate를…..</p><p>결론은 @UIApplication 어노테이션입니다.</p><p>@UIApplication 어노테이션이 붙은 사용자 정의 클래스를 UIApplication의 delegate로 사용합니다.</p><h3 id="UIWindow"><a href="#UIWindow" class="headerlink" title="UIWindow"></a>UIWindow</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br></pre></td></tr></table></figure><p>AppDelegate클래스를 보면 유일한 변수가 하나 있습니다. window<br>UIWindow 클래스이며 Optional로 nil을 가질 수 있습니다.</p><p>스토리보드 기반의 앱으로 구동되면 시스템에서 UIWindow객체를 할당하여 초기화하며, 코드기반의 경우 didFinishLaunchingWithOptions 타이밍에 직접 생성해줘야 합니다.</p><p>UIWindow 는 View를 담는 컨테이너 역할이며 다른 포스팅에서 더 자세히 다루도록 합니다.</p><h2 id="AppDelegate-메소드로-보는-iOS-LifeCycle"><a href="#AppDelegate-메소드로-보는-iOS-LifeCycle" class="headerlink" title="AppDelegate 메소드로 보는 iOS LifeCycle"></a>AppDelegate 메소드로 보는 iOS LifeCycle</h2><h3 id="1-앱-실행"><a href="#1-앱-실행" class="headerlink" title="1. 앱 실행"></a>1. 앱 실행</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>앱을 실행하면 호출되는 delegate 메소드. launchOptions 파라미터로 앱이 실행되게 된 이유 (푸시를 통한 실행) 등이 포함되어 실행된다.</p><ul><li>return은 왜 true로 고정되어 있을까?</li></ul><p>false로 바꿔도 앱은 정상적으로 실행되며, 아무 문제 없다.<br>return 값은 앱이 URL ( App Scheme ) 으로 실행된 경우 유효하다. URL로 실행 된 경우 launchOptions에 URL이 넘어오며 return을 false로 하면 openURL로 url을 오픈하지 않고 넘어간다.</p><ul><li>좀 더 연구가 필요!</li></ul><h3 id="2-앱-활성화"><a href="#2-앱-활성화" class="headerlink" title="2. 앱 활성화"></a>2. 앱 활성화</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidBecomeActive</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>앱이 화면에 뜬 이후 실행되는 메소드. 사실 WillBecomeActive도 있지만 자주 사용하지 않아서인지 AppDelegate에 기본적으로 override된 메소드는 applicationDidBecomeActive 였다.<br>앱이 백그라운드로 간 이후, 다시 포어그라운드로 올라온 이후에도 실행되는 메소드입니다.</p><h3 id="3-홈-버튼을-누르면"><a href="#3-홈-버튼을-누르면" class="headerlink" title="3. 홈 버튼을 누르면"></a>3. 홈 버튼을 누르면</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillResignActive</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</span></span><br><span class="line">        <span class="comment">// Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>홈 버튼을 누르면 앱은 백그라운드로 이동합니다. 가장 먼저 App이 포커스를 잃으면서 실행되는 메소드입니다.<br>템플릿 설명에 다르면 태스크 일시정지, 타이머 비활성화, 게임의 경우 일시정지를 처리하는 로직을 구현해야 하는 메소드입니다.</p><h3 id="4-백그라운드로-이동-후-화면에서-앱-안보임"><a href="#4-백그라운드로-이동-후-화면에서-앱-안보임" class="headerlink" title="4. 백그라운드로 이동 후 (화면에서 앱 안보임)"></a>4. 백그라운드로 이동 후 (화면에서 앱 안보임)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidEnterBackground</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span></span><br><span class="line">        <span class="comment">// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>앱이 백그라운드로 이동하여 더이상 앱이 보이지 않은 이후 호출되는 메소드.<br>이 메소드에서는 공유자원 해제, 유저 데이터 저장 등의 로직을 구현해야합니다.</p><h3 id="5-다시-앱-실행-메모리에-아직-살아있는-경우"><a href="#5-다시-앱-실행-메모리에-아직-살아있는-경우" class="headerlink" title="5. 다시 앱 실행 (메모리에 아직 살아있는 경우)"></a>5. 다시 앱 실행 (메모리에 아직 살아있는 경우)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillEnterForeground</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>자주 사용하는 메소드입니다.<br>앱이 다시 포어그라운드로 올라올 때 호출되는 메소드로, 보통 API를 통해 앱의 상태를 갱신할 때 사용합니다. 버전체크, 메인테이닝 체크 등..</p>]]></content>
    
    <summary type="html">
    
      AppDelegate 의 역할
UITableViewDelegate를 구현하다 =&gt; UITableView에서 필요한 기능을 대신 구현하다
라는 느낌으로 AppDelegate는 App( Application ) 이 해야할 일을 대신 구현한다는 의미입니다.

여기에서 App이 해야할 일이란, Background 진입, Foreground 진입, 외부에서의 요청 (apns) 등을 말합니다.

@UIApplicationMain 은 뭘까요?
1
2


@UIApplicationMain
class AppDelegate: UIResponder, 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>[Swift] iOS Widget Development. 위젯 iOS 앱 개발하기</title>
    <link href="http://monibu1548.github.io/2018/07/07/widget/"/>
    <id>http://monibu1548.github.io/2018/07/07/widget/</id>
    <published>2018-07-07T10:23:30.000Z</published>
    <updated>2018-07-07T14:46:26.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p><img src="../../../../images/widget/1.jpeg" alt=""></p><p>iOS11.3을 사용하고 있는 iPhone7 에서의 Widget 화면입니다. 앱 서비스 특징에 따라 위젯이 있으면 편리한 경우가 있습니다.</p><p>이번에 세번째로 52시간 근무시간 제도 시행에 맞춰 근무 시간을 체크할 수 있는 <code>퇴근요정</code> 앱을 배포했는데요.</p><p>다음 버전에서는 위젯도 제공하면 좋을 것 같아 공부도 할 겸 포스팅을 진행합니다.</p><h2 id="Widget-Target-생성"><a href="#Widget-Target-생성" class="headerlink" title="Widget Target 생성"></a>Widget Target 생성</h2><ol><li><p>위젯을 개발할 앱 프로젝트를 XCode에서 Open합니다.</p></li><li><p>File &gt; New &gt; Target 을 클릭합니다.</p></li></ol><p><img src="../../../../images/widget/2.png" alt=""></p><ol start="3"><li><p>Today Extension을 선택합니다. TodayExtension이 Widget을 말합니다.</p></li><li><p>Product Name을 입력합니다. 저는 그냥 Widget으로 만들었어요.</p></li><li><p>Target을 Widget으로 변경 후, 실행해봅니다.</p></li></ol><p><img src="../../../../images/widget/3.png" alt=""></p><ol start="6"><li>위젯 편집화면에서 WIDGET이 추가되었으며, 노출하게 설정하면 다음과 같이 <code>Hello World</code> 를 노출합니다.</li></ol><p><img src="../../../../images/widget/4.png" alt=""><br><img src="../../../../images/widget/5.jpeg" alt=""></p><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>Widget의 UI는 스토리보드를 이용합니다. Target 생성을 하면 자동으로 스토리보드 1개, 컨트롤러 1개, plist 1개가 추가되네요.</p><p>XCode가 만들어준 MainInterface.storyboard에 UI를 그려줍니다</p><p><img src="../../../../images/widget/6.png" alt=""></p><p>이걸 빌드하면</p><p><img src="../../../../images/widget/7.jpeg" alt=""></p><p>이렇게 나옵니다!!</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> NotificationCenter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetViewController</span>: <span class="title">UIViewController</span>, <span class="title">NCWidgetProviding</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view from its nib.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">widgetPerformUpdate</span><span class="params">(completionHandler: <span class="params">(@escaping <span class="params">(NCUpdateResult)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">        <span class="comment">// Perform any setup necessary in order to update the view.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If an error is encountered, use NCUpdateResult.Failed</span></span><br><span class="line">        <span class="comment">// If there's no update required, use NCUpdateResult.NoData</span></span><br><span class="line">        <span class="comment">// If there's an update, use NCUpdateResult.NewData</span></span><br><span class="line">        </span><br><span class="line">        completionHandler(<span class="type">NCUpdateResult</span>.newData)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 XCode에서 TodayExtension Target 생성시 자동으로 생성되는 템플릿 코드입니다.<br>viewDidLoad와 didReceiveMemoryWarning의 경우 일반 뷰컨트롤러와 별다를게 없습니다.</p><p>중요한건 <code>widgetPerformUpdate</code> 메소드 입니다. 위젯 페이지에서의 스크롤 등 위젯 업데이트가 필요한 경우 호출됩니다.<br>위 메소드에서 위젯 뷰에서 보여줄 내용을 업데이트 하면 됩니다.</p><p>자 그러면, 이제 WidgetViewController에서 기존 앱에서 사용하던 모듈을 가져와서 UI를 업데이트 작업을 하면 될 것 같은데..?</p><p>자동완성이 안되죠.</p><p>가져올 모듈 파일을 열고 Target membership을 설정해줘야합니다.</p><p><img src="../../../../images/widget/8.png" alt=""></p><p>쨘. 그럼 이제 자동완성이 되지요.</p><h2 id="망했다"><a href="#망했다" class="headerlink" title="망했다"></a>망했다</h2><p>기존 근무시간 데이터를 SQlite3를 이용해서 관리를 하고있었고, sharedInstance를 통해 CRUD를 진행중이었습니다.</p><p>위젯에서 불러오려고 하니… 위젯은 DB를 못읽어..오는 것..같네요.. :)</p><p>위젯에서는 API Request를 통해 UI를 갱신하는게 바람직해 보입니다. ㅠㅜ</p>]]></content>
    
    <summary type="html">
    
      Widget


iOS11.3을 사용하고 있는 iPhone7 에서의 Widget 화면입니다. 앱 서비스 특징에 따라 위젯이 있으면 편리한 경우가 있습니다.

이번에 세번째로 52시간 근무시간 제도 시행에 맞춰 근무 시간을 체크할 수 있는 퇴근요정 앱을 배포했는데요.

다음 버전에서는 위젯도 제공하면 좋을 것 같아 공부도 할 겸 포스팅을 진행합니다.

Widget Target 생성
 1. 위젯을 개발할 앱 프로젝트를 XCode에서 Open합니다.
    
    
 2. File &gt; New &gt; Target 을 클릭합니다.
    
 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Swift4 환경에서 sqlite3 DB 사용하기</title>
    <link href="http://monibu1548.github.io/2018/07/03/sqlite3/"/>
    <id>http://monibu1548.github.io/2018/07/03/sqlite3/</id>
    <published>2018-07-03T14:38:18.000Z</published>
    <updated>2018-07-04T11:44:46.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sqlite3를-이용하여-CRUD-구현하기"><a href="#Sqlite3를-이용하여-CRUD-구현하기" class="headerlink" title="Sqlite3를 이용하여 CRUD 구현하기"></a>Sqlite3를 이용하여 CRUD 구현하기</h2><p>Serverless한 앱을 주로 만들면 데이터를 로컬에 저장하게 되는데, 주로 UserDefault를 사용합니다. 데이터가 단순하고 양이 많지 않다면 상관없지만 CRUD 횟수가 많고 데이터 양이 많다면<br>Database 를 사용하는게 바람직합니다.</p><p>iOS Swift4환경에서 Sqlite3를 이용해서 데이터 CRUD를 구현하는 과정을 설명합니다.</p><h2 id="import-Sqlite3"><a href="#import-Sqlite3" class="headerlink" title="import Sqlite3"></a>import Sqlite3</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SQLite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkingTimeDBManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>근무시간을 관리하는 데이터를 저장하는 앱을 제작중입니다. 근무시간을 저장하기 위한 역할을 하는 WorkingTimeDBManager를 구현합니다.<br><code>import SQLite3</code> 로 해당 파일에서 SQLite3 모듈을 사용할 수 있도록 선언합니다.</p><p>WorkingTime 모델은</p><p>id : Primary 키<br>start : 근무 시작 시간<br>end : 근무 종료 시간</p><p>로 구성할 예정입니다.</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>가장 기본이 되는 CRUD 메소드를 선언합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createWorkingTime</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updateWorkingTime</span><span class="params">(id: Int, start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">readWorkingTimes</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">deleteWorkingTime</span><span class="params">(id: Int)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CRUD-Create"><a href="#CRUD-Create" class="headerlink" title="CRUD - Create"></a>CRUD - Create</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createWorkingTime</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> insertStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">let</span> insertStatementString = <span class="string">"INSERT INTO WorkingTimes (start, end) VALUES (?, ?);"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, insertStatementString, -<span class="number">1</span>, &amp;insertStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            </span><br><span class="line">            sqlite3_bind_int(insertStatement, <span class="number">1</span>, <span class="type">Int32</span>(start.timeIntervalSince1970))</span><br><span class="line">            sqlite3_bind_int(insertStatement, <span class="number">2</span>, <span class="type">Int32</span>(end.timeIntervalSince1970))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sqlite3_step(insertStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">                <span class="comment">// Success</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//Fail</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        sqlite3_finalize(insertStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>근무시간을 저장하는 메소드입니다. 근무시작시간과 종료 시간을 받아서 <code>WorkingTimes</code> 테이블에 start, end 컬럼에 데이터를 추가합니다. id 컬럼은 테이블 선언시 AUTOINCREMENT로 선언했습니다.</p><h3 id="CRUD-Read"><a href="#CRUD-Read" class="headerlink" title="CRUD - Read"></a>CRUD - Read</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">readWorkingTimes</span><span class="params">(start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> queryStatementString = <span class="string">"SELECT * FROM WorkingTimes;"</span></span><br><span class="line">        <span class="keyword">var</span> queryStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, queryStatementString, -<span class="number">1</span>, &amp;queryStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> sqlite3_step(queryStatement) == <span class="type">SQLITE_ROW</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> id = sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> queryResultCol1 = sqlite3_column_int(queryStatement, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">let</span> queryResultCol2 = sqlite3_column_int(queryStatement, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"\(id) | \(queryResultCol1) | \(queryResultCol2)"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fail</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sqlite3_finalize(queryStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WorkingTimes</code> 테이블의 모든 ROW를 읽어옵니다. while 문을 통해 읽어온 모든 ROW 에 대해 처리합니다.</p><h3 id="CRUD-Update"><a href="#CRUD-Update" class="headerlink" title="CRUD - Update"></a>CRUD - Update</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updateWorkingTime</span><span class="params">(id: Int, start: NSDate, end: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> updateStatementString = <span class="string">"UPDATE WorkingTimes SET start = "</span> +</span><br><span class="line">            <span class="type">String</span>(start.timeIntervalSince1970) +</span><br><span class="line">            <span class="string">", end = "</span> +</span><br><span class="line">            <span class="type">String</span>(end.timeIntervalSince1970) +</span><br><span class="line">        <span class="string">" WHERE id = "</span> + <span class="type">String</span>(id)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> updateStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, updateStatementString, -<span class="number">1</span>, &amp;updateStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sqlite3_step(updateStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">                <span class="comment">// Success</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fail</span></span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(updateStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>id에 해당하는 ROW 를 찾아서 start와 end column을 갱신합니다.</p><h3 id="CRUD-Delete"><a href="#CRUD-Delete" class="headerlink" title="CRUD - Delete"></a>CRUD - Delete</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">deleteWorkingTime</span><span class="params">(id: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> deleteStatementStirng = <span class="string">"DELETE FROM WorkingTimes WHERE id = "</span> + <span class="type">String</span>(id)</span><br><span class="line">        <span class="keyword">var</span> deleteStatement: <span class="type">OpaquePointer</span>? = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sqlite3_prepare_v2(db, deleteStatementStirng, -<span class="number">1</span>, &amp;deleteStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sqlite3_step(deleteStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">                <span class="comment">// Success</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fail</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sqlite3_finalize(deleteStatement)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WorkingTimes</code> 테이블에서 전달인자로 넘어온 id 에 해당하는 ROW 를 제거합니다.</p>]]></content>
    
    <summary type="html">
    
      Sqlite3를 이용하여 CRUD 구현하기
Serverless한 앱을 주로 만들면 데이터를 로컬에 저장하게 되는데, 주로 UserDefault를 사용합니다. 데이터가 단순하고 양이 많지 않다면 상관없지만 CRUD 횟수가 많고 데이터 양이 많다면
Database 를 사용하는게 바람직합니다.

iOS Swift4환경에서 Sqlite3를 이용해서 데이터 CRUD를 구현하는 과정을 설명합니다.

import Sqlite3
1
2
3
4
5
6


import UIKit
import SQLite3

class WorkingTimeDBMana
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Swift" scheme="http://monibu1548.github.io/categories/iOS/Swift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Firebase Cloud Messaging, Notification (Firebase를 이용한 iOS Push 전송)</title>
    <link href="http://monibu1548.github.io/2018/05/31/firebase-push/"/>
    <id>http://monibu1548.github.io/2018/05/31/firebase-push/</id>
    <published>2018-05-31T11:46:48.000Z</published>
    <updated>2018-05-31T12:34:58.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Firebase-Cloud-Messaging"><a href="#Firebase-Cloud-Messaging" class="headerlink" title="Firebase Cloud Messaging"></a>Firebase Cloud Messaging</h2><p>지난 포스팅에서는 iOS 앱의 Push Notification 기능을 추가하는 내용을 다뤘습니다.<br><a href="http://monibu1548.github.io/2018/05/29/push-cert/">iOS APN, Push Noticifation tutorial (Push 인증서 발급, 테스트 과정)</a></p><p>이제 이 기능을 실제 서비스에서 사용하기 위해 Firebase 를 사용하는 방법을 소개합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Firebase/Core&apos;</span><br><span class="line">pod &apos;Firebase/Messaging&apos;</span><br></pre></td></tr></table></figure><p>Podfile에 Cloud Messaging 기능을 사용하기 위해 위 2pod을 설치합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p><img src="../../../../images/firebase-push/1.png" alt=""><br>Firebase 앱 설정에서 APN 키를 등록해야합니다.<br>지난 포스팅에서는 Push 인증서를 만든것이고 APN 인증키는 따로있습니다. </p><h2 id="APN-인증키-발급받기"><a href="#APN-인증키-발급받기" class="headerlink" title="APN 인증키 발급받기"></a>APN 인증키 발급받기</h2><p><img src="../../../../images/firebase-push/2.png" alt=""><br><a href="https://developer.apple.com/account/ios/authkey/" target="_blank" rel="noopener">애플 개발자센터</a>에 들어갑니다.</p><p><img src="../../../../images/firebase-push/3.png" alt=""><br>Key 이름은 적당히 적고 APNs 선택 후 Continue~!</p><p><img src="../../../../images/firebase-push/4.png" alt=""><br>쨘! APN Key가 쉽게 생성됩니다. 여기서 <code>.p8</code> APN 인증서를 다운받습니다. <code>잘 챙겨주세요!</code></p><p>자 이제 다시 Firebase로 돌아옵니다.<br><img src="../../../../images/firebase-push/5.png" alt=""><br>다운받은 APN 인증키를 넣고<br>키 ID 는 인증키 파일 뒤 suffix입니다.<br>앱 ID prefix는 teamID 입니다.</p><p><img src="../../../../images/firebase-push/6.png" alt=""><br>APN Key가 정상적으로 등록된 것을 볼 수 있습니다.</p><h2 id="XCode-에서-Firebase-Push-사용할-수-있도록-설정하기"><a href="#XCode-에서-Firebase-Push-사용할-수-있도록-설정하기" class="headerlink" title="XCode 에서 Firebase Push 사용할 수 있도록 설정하기"></a>XCode 에서 Firebase Push 사용할 수 있도록 설정하기</h2><p>AppDelegate에서 Firebase 설정하기</p><p>Appdelegate.swift 파일에 Firebase 모듈을 import 합니다</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Firebase</span><br></pre></td></tr></table></figure><p><code>application:didFinishLaunchingWithOptions:</code> 메소드에서 Firebase 모듈을 초기화합니다.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FirebaseApp</span>.configure()</span><br></pre></td></tr></table></figure></p><p>Push Notification을 등록할 위치에 다음 코드를 삽입합니다<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</span><br><span class="line">  <span class="comment">// For iOS 10 display notification (sent via APNS)</span></span><br><span class="line">  <span class="type">UNUserNotificationCenter</span>.current().delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> authOptions: <span class="type">UNAuthorizationOptions</span> = [.alert, .badge, .sound]</span><br><span class="line">  <span class="type">UNUserNotificationCenter</span>.current().requestAuthorization(</span><br><span class="line">    options: authOptions,</span><br><span class="line">    completionHandler: &#123;<span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span> &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> settings: <span class="type">UIUserNotificationSettings</span> =</span><br><span class="line">  <span class="type">UIUserNotificationSettings</span>(types: [.alert, .badge, .sound], categories: <span class="literal">nil</span>)</span><br><span class="line">  application.registerUserNotificationSettings(settings)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application.registerForRemoteNotifications()</span><br></pre></td></tr></table></figure></p><p>후후 그럼 끝났습니다.</p><h2 id="Firebase에서-Push-Notification-보내기"><a href="#Firebase에서-Push-Notification-보내기" class="headerlink" title="Firebase에서 Push Notification 보내기"></a>Firebase에서 Push Notification 보내기</h2><p><img src="../../../../images/firebase-push/7.png" alt=""><br>메세지 내용에 Push 내용을 입력합니다.</p><p>앱 드랍다운 버튼을 클릭하면 Firebase에 등록한 프로젝트들이 뜨는데요, 이 중에서 Push 보낼 앱을 선택합니다.</p><p>그리고 <code>메세지 보내기</code> 클릭!</p><p>그러면 아이폰에 remote Notification 이 뙇!</p><p>메세지를 보낼때 예약도 가능합니다.</p><p>시간대별로 적절한 푸시를 통해 사용자 진입을 늘릴 수 있습니다!</p>]]></content>
    
    <summary type="html">
    
      Firebase Cloud Messaging
지난 포스팅에서는 iOS 앱의 Push Notification 기능을 추가하는 내용을 다뤘습니다.
iOS APN, Push Noticifation tutorial (Push 인증서 발급, 테스트 과정)

이제 이 기능을 실제 서비스에서 사용하기 위해 Firebase 를 사용하는 방법을 소개합니다.

1
2


pod &#39;Firebase/Core&#39;
pod &#39;Firebase/Messaging&#39;


Podfile에 Cloud Messaging 기능을 사용하기 위해 위 2pod을 설치합니다.

1
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/tags/Firebase/"/>
    
      <category term="앱 고도화" scheme="http://monibu1548.github.io/tags/%EC%95%B1-%EA%B3%A0%EB%8F%84%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>iOS APN, Push Noticifation tutorial (Push 인증서 발급, 테스트 과정)</title>
    <link href="http://monibu1548.github.io/2018/05/29/push-cert/"/>
    <id>http://monibu1548.github.io/2018/05/29/push-cert/</id>
    <published>2018-05-29T11:49:03.000Z</published>
    <updated>2018-05-29T13:55:10.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="푸시-인증서-발급받기"><a href="#푸시-인증서-발급받기" class="headerlink" title="푸시 인증서 발급받기"></a>푸시 인증서 발급받기</h2><p>iOS에서 Push 기능을 사용하기 위해서 Push Certificate, 푸시 인증서가 필요합니다. 푸시 인증서를 발급받는 방법은 개발 인증서 발급과정과 비슷합니다.</p><h3 id="Apple-Developers"><a href="#Apple-Developers" class="headerlink" title="Apple Developers"></a>Apple Developers</h3><p><img src="../../../../images/push-cert/1.png" alt=""><br><a href="https://developer.apple.com/account/ios/certificate/" target="_blank" rel="noopener">애플 개발자센터</a>에 로그인합니다.</p><p><code>+</code> 버튼을 눌러줍니다.</p><p><img src="../../../../images/push-cert/2.png" alt=""><br>개발용 인증서 발급페이지와 동일합니다. 빨간색으로 표시한 부분이 Push 인증서입니다.<br>개발용 인증서와 마찬가지로 Development(개발용)와 Production(앱스토어용) 으로 분리되어 있으며 필요에 따라 생성하면 됩니다.<br>우선 Development용을 발급받습니다.</p><p><img src="../../../../images/push-cert/3.png" alt=""><br>어떤 앱의 Push 인증서를 만들 것인지 선택합니다.</p><p><img src="../../../../images/push-cert/4.png" alt=""><br>CSR(Certificate Signing Request)가 필요하다는 안내 페이지입니다.<br>CSR발급은 앱 인증서 발급 과정을 참고해주세요.</p><p><a href="http://monibu1548.github.io/2018/04/15/apple-development/">iOS Application 개발 시작하기 - 1 (개발자 등록, 인증서 등록)</a></p><p><img src="../../../../images/push-cert/5.png" alt=""><br>CSR파일을 선택하고 Continue 버튼을 클릭합니다.</p><p><img src="../../../../images/push-cert/6.png" alt=""><br>Push인증서 발급이 완료되었습니다. 같은 과정으로 Production환경의 Push인증서도 발급받습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">참고로 Push 인증서는 앱 인증서처럼 개발 맥북에 등록하여 사용하는 것이 아닙니다.</span><br><span class="line">Push용 인증서는 iOS앱에 Push Notification을 발생시킬 때 사용하는 인증서입니다.</span><br></pre></td></tr></table></figure><h2 id="프로비저닝-재발급"><a href="#프로비저닝-재발급" class="headerlink" title="프로비저닝 재발급"></a>프로비저닝 재발급</h2><p>지난번 프로비저닝 발급 포스트(<a href="http://monibu1548.github.io/2018/04/15/apple-development/">iOS Application 개발 시작하기 - 1 (개발자 등록, 인증서 등록)</a>)에서 프로비저닝에는 Certificate 정보가 포함된다고 소개했습니다.</p><p>따라서, Push를 위해 Certificate를 재발급 받았으니 프로비저닝도 재발급 받아야 합니다.<br>이런 귀찮음을 피하기 위해서는 앱 개발 프로젝트 초기단계에 한번에 다 발급받는 것도 방법입니다 :)</p><p><img src="../../../../images/push-cert/7.png" alt=""><br>프로비저닝을 재발급 받기위해 위 페이지에 접속하면 아마 빨간색 부분이 <code>invalid</code>라고 뜰겁니다. 저는 이미 재발급을 받아버려서 active라고 나옵니다.<br>이 프로비저닝을 Delete하고 재발급 받아도 되지만 <code>Edit</code> 버튼으로 들어가서 <code>Generate</code> 해주면 자동으로 Push Certificate 가 업데이트 된 프로비저닝을 쉽게 받을 수도 있습니다.</p><p><img src="../../../../images/push-cert/8.png" alt=""><br>프로비저닝 정보를 보면 <code>Push Notifications</code>가 추가된 것을 볼 수 있습니다.</p><p>다운로드받아서 더블클릭! 해주세요.</p><h2 id="XCode-프로젝트-설정"><a href="#XCode-프로젝트-설정" class="headerlink" title="XCode 프로젝트 설정"></a>XCode 프로젝트 설정</h2><p>이제 프로젝트 설정에 들어가서 Push를 사용하겠다고 선언해봅시다.<br>XCode를 열고 프로젝트 파일 -&gt; <code>Capabilities</code> 탭으로 진입합니다.</p><p><img src="../../../../images/push-cert/9.png" alt=""><br>네, 친절하게 <code>Push Notifications</code>라고 있습니다. Off -&gt; On 으로 변경해줍니다.</p><p><img src="../../../../images/push-cert/10.png" alt=""><br>지금까지 잘 진행했다면 위와 같이 2개의 체크!를 볼 수 있습니다. 프로비저닝 또는 Push 인증서에 문제가 있다면 이곳에 표시됩니다.</p><h2 id="Push-Permission-획득"><a href="#Push-Permission-획득" class="headerlink" title="Push Permission 획득"></a>Push Permission 획득</h2><p>이제 정말 Push가 오는지, 보낼 수 있는지 확인이 필요합니다.</p><p><code>AppDelegate</code>파일의 didFinishLaunchingWithOptions 메소드에 다음의 코드를 작성합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">UNUserNotificationCenter</span>.current().requestAuthorization(options: [.alert, .sound, .badge]) &#123;</span><br><span class="line">        (granted, error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> granted <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            application.registerForRemoteNotifications()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/push-cert/11.jpeg" alt=""><br>Push도 위치정보, 사진정보등과 같이 Native를 활용하기 때문에 사용자의 권한 동의가 필요하기 때문에 동의를 얻는 코드입니다.<br>위의 코드를 넣으면 앱 실행시 사용자에게 다음과 같은 Alert으로 알람 동의를 얻습니다.</p><h2 id="Device-Token-확인"><a href="#Device-Token-확인" class="headerlink" title="Device Token 확인"></a>Device Token 확인</h2><p>이제 디바이스 토큰 확인을 위해 AppDelegate파일에 <code>didRegisterForRemoteNotificationsWithDeviceToken</code> 메소드를 오버라이드 합니다<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span>   tokenString = deviceToken.<span class="built_in">reduce</span>(<span class="string">""</span>, &#123;$<span class="number">0</span> + <span class="type">String</span>(format: <span class="string">"%02X"</span>, $<span class="number">1</span>)&#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"deviceToken: \(tokenString)"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>시뮬레이터에서는 다르게 동작할 수 있습니다. 정확한 테스트를 위해 실제 디바이스에서 진행해주세요.</code></p><p>device token을 확인하기 위해 console에 tokenString을 출력하도록 해봅니다.</p><p><img src="../../../../images/push-cert/12.png" alt=""><br>앱을 실행하고 Push 권한을 허용하면 콘솔창에 위와 같은 로그가 찍힙니다.</p><h2 id="APN-Easy-Provider"><a href="#APN-Easy-Provider" class="headerlink" title="APN Easy Provider"></a>APN Easy Provider</h2><p>이제 Push 테스트를 진행합니다. AppStore에서 <code>APN easy Provider</code>를 설치해줍니다.</p><p><img src="../../../../images/push-cert/13.png" alt=""><br>이렇게 생겼습니다.</p><p><img src="../../../../images/push-cert/14.png" alt=""><br><code>Add Tokens..</code> 버튼을 눌러 전 단계에서 얻었던 Device Token을 등록합니다.</p><p><img src="../../../../images/push-cert/15.png" alt=""><br>Device Token 입력 후 <code>Confirm</code>을 선택합니다. Name은 아무거나 등록해주세요.</p><p>다음은 <code>2.Choose Certificate File</code> 을 클릭합니다. 여기서는 애플 개발자센터에서 생성한 Push Certificate를 등록해야합니다.<br>애플 개발자센터에서 다운받은 Push Certificate 파일을 더블클릭하면  <code>키체인 접근</code>에 등록이 됩니다.</p><p><img src="../../../../images/push-cert/16.png" alt=""><br>인증서를 오른쪽 버튼으로 클릭 후 <code>~~~ 내보내기</code>를 선택합니다. 파일 확장자를 <code>.cer</code>로 하여 편한 위치에 내보냅니다.</p><p>이제 다시 APN Easy Provider에서 방금 내보내기로 만든 .cer 형태의 Push certificate를 선택합니다.</p><p>그리고 <code>3. Connect to:</code>를 클릭합니다. 우측의 드랍다운메뉴는 <code>gateway.sandbox.push.apple.com</code>을 선택합니다.</p><p><img src="../../../../images/push-cert/17.png" alt=""><br>apple의 apn server에 연결되면 Status에</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connecting to gateway.sandbox.push.apple.com</span><br><span class="line">Connected to server, validating identity...</span><br><span class="line">Connected to APN server successfully</span><br></pre></td></tr></table></figure><p>라고 뜹니다. 이제 Push 테스트 환경 구축이 끝났습니다.</p><p><img src="../../../../images/push-cert/18.png" alt=""></p><p>Push Noti의 타이틀과 내용을 작성 후 <code>5. Send APN</code> 버튼을 눌러봅니다.</p><p><img src="../../../../images/push-cert/19.png" alt=""></p><p>쨘!</p><h2 id="실제-프로젝트에-적용하려면"><a href="#실제-프로젝트에-적용하려면" class="headerlink" title="실제 프로젝트에 적용하려면"></a>실제 프로젝트에 적용하려면</h2><p>위 과정은 앱에 Push기능을 넣고 제대로 동작하는지 과정일 뿐입니다.<br>실제 프로젝트에서 Push를 적용하기 위해서는 앱들의 디바이스 토큰을 관리하고 푸시를 발생시킬 서버를 필요로 합니다.<br>서비스의 로직에 따라 적절한 타이밍에 적절한 Push Noti를 발생시키는 것은 이제 서비스의 역할입니다.</p><p>다음포스트에서는 Firebase를 활용하여 프로젝트에서 Push를 활용하는 방법을 소개합니다.</p>]]></content>
    
    <summary type="html">
    
      푸시 인증서 발급받기
iOS에서 Push 기능을 사용하기 위해서 Push Certificate, 푸시 인증서가 필요합니다. 푸시 인증서를 발급받는 방법은 개발 인증서 발급과정과 비슷합니다.

Apple Developers

애플 개발자센터에 로그인합니다.

+ 버튼을 눌러줍니다.


개발용 인증서 발급페이지와 동일합니다. 빨간색으로 표시한 부분이 Push 인증서입니다.
개발용 인증서와 마찬가지로 Development(개발용)와 Production(앱스토어용) 으로 분리되어 있으며 필요에 따라 생성하면 됩니다.
우선 Developme
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Content Mode : Scale to Fill, Aspect Fit, Aspect Fill 차이 정리</title>
    <link href="http://monibu1548.github.io/2018/05/21/scalemode/"/>
    <id>http://monibu1548.github.io/2018/05/21/scalemode/</id>
    <published>2018-05-21T13:50:52.000Z</published>
    <updated>2018-05-29T12:05:31.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scale-To-Fill-기본값"><a href="#Scale-To-Fill-기본값" class="headerlink" title="Scale To Fill (기본값)"></a>Scale To Fill (기본값)</h2><p><img src="../../../../images/scale/1.png" alt=""></p><ul><li>비율 무시! 귀여운 고양이가 옆으로 퍼져버렸습니다.</li><li>ImageView의 Width와 height에 이미지를 늘리고 우겨넣습니다.</li><li>디자인 가이드로 정해진 레이아웃과 이미지가 아니면 이렇게 이미지를 괴롭히면 안돼요.</li></ul><h2 id="Aspect-To-Fit"><a href="#Aspect-To-Fit" class="headerlink" title="Aspect To Fit"></a>Aspect To Fit</h2><p><img src="../../../../images/scale/2.png" alt=""></p><ul><li>비율 유지! 원본의 비율을 그대로 유지합니다.</li><li>이미지는 <code>절대</code> ImageView 밖으로 나가지 않습니다.</li><li>ImageView 내부에서 밖으로 나가지 않는 선에서 최대치의 값을 갖습니다.</li><li>비율이 맞지 않는경우 내부에 <code>여백</code> 이 생기게 됩니다.</li></ul><h2 id="Aspect-To-Fill"><a href="#Aspect-To-Fill" class="headerlink" title="Aspect To Fill"></a>Aspect To Fill</h2><p><img src="../../../../images/scale/3.png" alt=""></p><ul><li>비율 유지! 원본의 비율을 그대로 유지합니다… 만 이미지가 짤리죠</li><li>위 사진에서 짤리는 부분이 없어보이지만 자세히 보면 이미지가 ImageView 영역 밖으로 나갔음을 알 수 있습니다. (Clip to Bounds) 값을 YES로 하면 짤려서 나오지 않습니다.</li><li>ImageView의 내부에 <code>여백</code>이 절대 생기지 않습니다.</li><li>대신 이미지의 일부가 짤려보일 수 있으므로 인물, 동물 사진에는 적합하지 않을 수 있습니다.</li></ul>]]></content>
    
    <summary type="html">
    
      Scale To Fill (기본값)


 * 비율 무시! 귀여운 고양이가 옆으로 퍼져버렸습니다.
 * ImageView의 Width와 height에 이미지를 늘리고 우겨넣습니다.
 * 디자인 가이드로 정해진 레이아웃과 이미지가 아니면 이렇게 이미지를 괴롭히면 안돼요.

Aspect To Fit


 * 비율 유지! 원본의 비율을 그대로 유지합니다.
 * 이미지는 절대 ImageView 밖으로 나가지 않습니다.
 * ImageView 내부에서 밖으로 나가지 않는 선에서 최대치의 값을 갖습니다.
 * 비율이 맞지 않는경우 내부에 여백 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 앱 업데이트 (강제 업데이트, 선택 업데이트) 기능 구현 예제</title>
    <link href="http://monibu1548.github.io/2018/05/19/remote-config-forced-update/"/>
    <id>http://monibu1548.github.io/2018/05/19/remote-config-forced-update/</id>
    <published>2018-05-18T16:08:15.000Z</published>
    <updated>2018-05-29T12:05:16.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="사용자에게-앱-업데이트-안내하기"><a href="#사용자에게-앱-업데이트-안내하기" class="headerlink" title="사용자에게 앱 업데이트 안내하기"></a>사용자에게 앱 업데이트 안내하기</h2><p>새로운 버전의 앱이 출시되면 AppStore에 등록되고, <code>설정 -&gt; Apple ID -&gt; iTunes 및 App Store -&gt; 자동 다운로드(업데이트)</code> 가 켜져있다면 보통 새벽시간에 자동 업데이트가 됩니다.<br>하지만 사용자가 자동 업데이트 기능을 꺼두었다면?</p><p>새로운 앱 버전의 출시를 알 수 없습니다.</p><p>가장 큰 문제는, 기존 배포버전에 치명적인 버그가 있을때 Hot-fix 배포를 하더라도 자동업데이트 옵션 미사용 사용자들에게는 새로운 버전을 안내할 수 없다는 것 입니다.</p><p>그래서 앱 개발 초기단계에 업데이트 안내 관련 코드를 넣는것이 필수라고 생각합니다.</p><h2 id="업데이트의-구분"><a href="#업데이트의-구분" class="headerlink" title="업데이트의 구분"></a>업데이트의 구분</h2><p>업데이트의 종류는 보통 <code>강제업데이트</code>, <code>선택업데이트</code> 2가지로 나뉩니다.</p><p><code>강제 업데이트</code> 란 앱이 새로운 버전으로 올라가면서 기존 앱과 호환이 불가하거나, 치명적인 버그가 있어 기존 앱의 이용자를 모두 <code>필수적으로</code> 새로운 버전의 앱을 사용하도록 할 때 사용합니다. 앱 실행시 강제 업데이트가 필요한지의 여부를 판단 후, 강제 업데이트가 필요하다면 앱 진입을 막고 앱스토어로 연결하여 업데이트를 할 수 있도록 안내합니다. 이 방법을 사용하면 기존 앱은 전혀 사용할 수 없게 되어, 기존 사용자들의 사용성은 떨어지게 되므로 꼭 사용해야하는 경우가 아니면 <code>선택 업데이트</code> 사용을 권장합니다.</p><p><code>선택 업데이트</code> 란 앱이 새로운 버전으로 올라가지만 큰 변화가 없어서, 기존 앱과 호환이 가능하여 새로운 업데이트가 있다고만 안내합니다.</p><h2 id="업데이트-안내-로직"><a href="#업데이트-안내-로직" class="headerlink" title="업데이트 안내 로직"></a>업데이트 안내 로직</h2><ul><li><p>사용자가 앱을 실행 or 백그라운드에서 포어그라운드로 진입</p></li><li><p>서버에서 <code>앱 최소 지원 버전</code>, <code>최신 앱 버전</code> 을 내려받아 현재 앱의 버전과 비교합니다.</p></li><li><p><code>현재 앱의 버전</code> &lt; <code>앱 최소 지원 버전</code>  =&gt;  강제 업데이트 로직으로 분기</p></li><li><p><code>현재 앱의 버전</code> &lt; <code>최신 앱 버전</code>  =&gt; 선택 업데이트 로직으로 분기</p></li></ul><h2 id="앱의-최소-최신-버전-관리"><a href="#앱의-최소-최신-버전-관리" class="headerlink" title="앱의 최소, 최신 버전 관리"></a>앱의 최소, 최신 버전 관리</h2><p>필수 또는 선택 업데이트의 필요 유무를 판단하기 위해서는 <code>앱 최소지원 버전</code>, <code>최신 앱 버전</code>을 알 수 있어야 합니다. 이 정보를 위해 서버가 필요한가 싶은 이때!<br>우리에겐 <code>Firebase</code>가 있습니다.</p><p>지난 포스팅 <a href="http://monibu1548.github.io/2018/05/14/firebase-config/">iOS앱 고도화 - Firebase Remote Config를 사용한 앱 운영방법</a> 을 참고해주세요.</p><p>Firebase Remote Config에 앱의 버전정보를 등록하여 사용할 수 있습니다.</p><h2 id="앱-실행시-버전체크-예제"><a href="#앱-실행시-버전체크-예제" class="headerlink" title="앱 실행시 버전체크 예제"></a>앱 실행시 버전체크 예제</h2><h3 id="AppDelegate-m"><a href="#AppDelegate-m" class="headerlink" title="AppDelegate.m"></a>AppDelegate.m</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.window?.rootViewController = <span class="type">UIStoryboard</span>.<span class="keyword">init</span>(name: <span class="string">"LaunchScreen"</span>, bundle: <span class="literal">nil</span>).instantiateInitialViewController()</span><br><span class="line">    <span class="type">RemoteConfigManager</span>.sharedManager.launching(completionHandler: &#123; (config) <span class="keyword">in</span>      </span><br><span class="line">    &#125;, forceUpdate: &#123; (forceUpdate) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> !forceUpdate &#123;</span><br><span class="line">            <span class="keyword">let</span> vc = <span class="type">UIStoryboard</span>.<span class="keyword">init</span>(name: <span class="string">"Home"</span>, bundle: <span class="literal">nil</span>).instantiateInitialViewController()</span><br><span class="line">            <span class="keyword">self</span>.window?.rootViewController = vc</span><br><span class="line">            <span class="keyword">self</span>.window?.makeKeyAndVisible()</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppDelegate.m의 didFinishLaunchingWithOptions 메소드입니다.<br>앱 진입 시점에서 window의 rootViewController를 <code>LaunchScreen</code>으로 바꿔치기합니다. 앱 버전을 확인하지 않고 바로 앱으로 진입하는 것을 막기 위함입니다.<br>그 이후 RemoteConfigManager에서 firebase의 remote config를 가져오는 메소드를 호출합니다.<br>RemoteConfigManger의 코드입니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Firebase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastestVersion: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> minVersion: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteConfigManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">RemoteConfigManager</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">launching</span><span class="params">(completionHandler: @escaping <span class="params">(<span class="number">_</span> conf: AppConfig)</span></span></span> -&gt; (), forceUpdate:@escaping (<span class="number">_</span> need: <span class="type">Bool</span>)-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">let</span> remoteConfig = <span class="type">RemoteConfig</span>.remoteConfig()</span><br><span class="line">        </span><br><span class="line">        remoteConfig.fetch(withExpirationDuration: <span class="type">TimeInterval</span>(<span class="number">3600</span>)) &#123; (status, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> status == .success &#123;</span><br><span class="line">                remoteConfig.activateFetched()</span><br><span class="line">          </span><br><span class="line">                <span class="comment">// 데이터 Fetch</span></span><br><span class="line">                <span class="keyword">let</span> appConfig: <span class="type">AppConfig</span> = <span class="type">AppConfig</span>()</span><br><span class="line">                appConfig.lastestVersion = remoteConfig[<span class="string">"lastest_version"</span>].stringValue</span><br><span class="line">                appConfig.minVersion = remoteConfig[<span class="string">"min_version"</span>].stringValue</span><br><span class="line"></span><br><span class="line">                completionHandler(appConfig)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 강제업데이트</span></span><br><span class="line">                <span class="keyword">let</span> needForcedUpdate:<span class="type">Bool</span> = (<span class="keyword">self</span>.compareVersion(versionA: <span class="type">ConfigEnv</span>.appVersion(), versionB: appConfig.minVersion) == <span class="type">ComparisonResult</span>.orderedAscending)</span><br><span class="line">                forceUpdate(needForcedUpdate)</span><br><span class="line">                <span class="keyword">if</span> needForcedUpdate &#123;</span><br><span class="line">                    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, message: <span class="string">"필수 업데이트가 있습니다. 업데이트하시겠습니까?"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</span><br><span class="line">                    alertController.addAction(<span class="type">UIAlertAction</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: &#123; (action) <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">// 앱스토어마켓으로 이동</span></span><br><span class="line">                    &#125;))</span><br><span class="line">                    <span class="keyword">var</span> topController = <span class="type">UIApplication</span>.shared.keyWindow?.rootViewController</span><br><span class="line">                    <span class="keyword">if</span> topController != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> <span class="keyword">let</span> presentedViewController = topController?.presentedViewController &#123;</span><br><span class="line">                            topController = presentedViewController</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    topController!.present(alertController, animated: <span class="literal">false</span>, completion: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 선택업데이트</span></span><br><span class="line">                <span class="keyword">let</span> needUpdate:<span class="type">Bool</span> = (<span class="keyword">self</span>.compareVersion(versionA: <span class="type">ConfigEnv</span>.appVersion(), versionB: appConfig.minVersion) != <span class="type">ComparisonResult</span>.orderedAscending) &amp;&amp; (<span class="keyword">self</span>.compareVersion(versionA: <span class="type">ConfigEnv</span>.appVersion(), versionB: appConfig.lastestVersion) == <span class="type">ComparisonResult</span>.orderedAscending)</span><br><span class="line">                <span class="keyword">if</span> needUpdate &#123;</span><br><span class="line">                    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, message: <span class="string">"최신 업데이트가 있습니다. 업데이트하시겠습니까?"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</span><br><span class="line">                    alertController.addAction(<span class="type">UIAlertAction</span>.<span class="keyword">init</span>(title: <span class="string">"업데이트"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: &#123; (action) <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">// 앱스토어마켓으로 이동</span></span><br><span class="line">                    &#125;))</span><br><span class="line">                    alertController.addAction(<span class="type">UIAlertAction</span>.<span class="keyword">init</span>(title: <span class="string">"나중에"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: &#123; (action) <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">// 앱으로 진입</span></span><br><span class="line">                    &#125;))</span><br><span class="line">                    <span class="keyword">var</span> topController = <span class="type">UIApplication</span>.shared.keyWindow?.rootViewController</span><br><span class="line">                    <span class="keyword">if</span> topController != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> <span class="keyword">let</span> presentedViewController = topController?.presentedViewController &#123;</span><br><span class="line">                            topController = presentedViewController</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    topController!.present(alertController, animated: <span class="literal">false</span>, completion: &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">compareVersion</span><span class="params">(versionA:String!, versionB:String!)</span></span> -&gt; <span class="type">ComparisonResult</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> majorA = <span class="type">Int</span>(<span class="type">Array</span>(versionA.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">0</span>])!</span><br><span class="line">        <span class="keyword">let</span> majorB = <span class="type">Int</span>(<span class="type">Array</span>(versionB.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">0</span>])!</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> majorA &gt; majorB &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedDescending</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> majorB &gt; majorA &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedAscending</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> minorA = <span class="type">Int</span>(<span class="type">Array</span>(versionA.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">1</span>])!</span><br><span class="line">        <span class="keyword">let</span> minorB = <span class="type">Int</span>(<span class="type">Array</span>(versionB.<span class="built_in">split</span>(separator: <span class="string">"."</span>))[<span class="number">1</span>])!</span><br><span class="line">        <span class="keyword">if</span> minorA &gt; minorB &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedDescending</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> minorB &gt; minorA &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedAscending</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ComparisonResult</span>.orderedSame</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Firebase Remote Config에서 데이터를 Fetch 한 뒤에 <code>AppConfig</code> 라는 클래스에 매핑을 합니다. 그 이후 plist에 있는 현재 앱의 버전과 AppConfig의 minVersion, lastestVersion을 비교하여 강제, 선택 업데이트 여부를 판단합니다.<br>AppConfig 클래스의 변수들이 저렇게 생긴 이유는 Firebase에서 이렇게 설정했기 때문입니다.</p><p><img src="../../../../images/update/1.png" alt=""></p><p><code>compareVersion</code>이라는 메소드로 현재버전과 최소, 최신 버전을 확인하여 적절한 AlertController를 노출합니다.</p><h2 id="강제-업데이트-화면"><a href="#강제-업데이트-화면" class="headerlink" title="강제 업데이트 화면"></a>강제 업데이트 화면</h2><p><img src="../../../../images/update/2.png" alt=""></p><p> AlertController의 버튼으로 <code>업데이트</code> 하나만 노출하며, 클릭시 앱스토어 이동하여 업데이트를 안내합니다. 그 외 앱의 진입방법은 없으므로 사용자는 업데이트 없이 기존 앱을 사용할 수 없습니다.</p><h2 id="선택-업데이트-화면"><a href="#선택-업데이트-화면" class="headerlink" title="선택 업데이트 화면"></a>선택 업데이트 화면</h2><p> <img src="../../../../images/update/3.png" alt=""></p><p> AlertController의 버튼으로 <code>업데이트</code>와 <code>나중에</code>를 노출하여, 앱스토어로 이동하여 업데이트를 할지, 그냥 앱으로 진입할지 사용자에게 선택권을 부여합니다.</p><p><code>추가적으로</code></p><p>업데이트를 안 한 경우, 앱을 실행 할때마다 선택 업데이트 Alert이 뜨는데요, 사용자의 불편을 최소화 하기 위해서 <code>7일간 보지않기</code> 등을 추가하는 것이 좋습니다.</p><h2 id="iOS-개발자가-업데이트-로직을-사용할-때-앱의-배포-과정"><a href="#iOS-개발자가-업데이트-로직을-사용할-때-앱의-배포-과정" class="headerlink" title="iOS 개발자가 업데이트 로직을 사용할 때 앱의 배포 과정"></a>iOS 개발자가 업데이트 로직을 사용할 때 앱의 배포 과정</h2><ul><li>앱을 개발하면서 <code>강제 업데이트</code>를 사용할지, <code>선택 업데이트</code>를 사용할지 결정</li></ul><h3 id="선택-업데이트라면"><a href="#선택-업데이트라면" class="headerlink" title="선택 업데이트라면?"></a>선택 업데이트라면?</h3><ul><li>새로운 버전의 앱이 AppStore에 노출됨을 확인하고 Remote Config 설정에서 <code>lastestVersion</code>을 최신버전으로 수정합니다.</li></ul><h3 id="강제-업데이트라면"><a href="#강제-업데이트라면" class="headerlink" title="강제 업데이트라면?"></a>강제 업데이트라면?</h3><ul><li>새로운 버전의 앱이 AppStore에 노출됨을 확인하고 Remote Config 설정에서 <code>minVersion</code>을 최신버전으로 수정합니다. 물론 <code>lastestVersion</code>도 최신으로 수정합니다.</li></ul><ul><li><code>주의사항</code></li></ul><ul><li>앱을 실행할 때 앱의 진입을 막고, remote config의 데이터를 가져오는 로직이 추가됩니다. firebase 서비스에 장애가 생길일은 드물겠지만, 만약 장애가 있다면 앱에 진입이 불가할 수 있습니다.</li><li>firebase remote config 설정이 즉시 적용은 아니고, 조금의 시간이 소요됩니다. (몇분정도?)</li><li>아직 앱스토어에 업데이트된 빌드가 업로드 되지 않은 상태에서, 강제 업데이트를 설정하면 사용자는 앱을 사용할 수 없습니다.</li><li>업데이트 빌드가 앱스토어에 노출되는 시점이 사용자마다 다를 수 있습니다. 어떤 사용자는 앱스토어에 들어가면 <code>업데이트</code>가 바로 뜨지만, 일부 사용자는 <code>열기</code> 버전으로 기존 버전만 사용가능 할 수 있습니다. 이때, 강제 업데이트 걸면 후자의 사람들은 업데이트가 가능해질 때까지 앱을 사용할 수 없습니다.</li><li>위의 이슈는 사용자가 앱스토어의 업데이트 탭에서 새로고침을 하면 수정되긴 합니다.</li></ul>]]></content>
    
    <summary type="html">
    
      사용자에게 앱 업데이트 안내하기
새로운 버전의 앱이 출시되면 AppStore에 등록되고, 설정 -&gt; Apple ID -&gt; iTunes 및 App Store -&gt; 자동 다운로드(업데이트) 가 켜져있다면 보통 새벽시간에 자동 업데이트가 됩니다.
하지만 사용자가 자동 업데이트 기능을 꺼두었다면?

새로운 앱 버전의 출시를 알 수 없습니다.

가장 큰 문제는, 기존 배포버전에 치명적인 버그가 있을때 Hot-fix 배포를 하더라도 자동업데이트 옵션 미사용 사용자들에게는 새로운 버전을 안내할 수 없다는 것 입니다.

그래서 앱 개발 초기단계에
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/tags/Firebase/"/>
    
      <category term="업데이트" scheme="http://monibu1548.github.io/tags/%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/"/>
    
      <category term="RemoteConfig" scheme="http://monibu1548.github.io/tags/RemoteConfig/"/>
    
  </entry>
  
  <entry>
    <title>Google Analytics example(구글 애널리틱스를 이용한 앱 운영)</title>
    <link href="http://monibu1548.github.io/2018/05/17/ga/"/>
    <id>http://monibu1548.github.io/2018/05/17/ga/</id>
    <published>2018-05-17T11:24:56.000Z</published>
    <updated>2018-05-29T12:04:57.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Analytics의-필요성"><a href="#Analytics의-필요성" class="headerlink" title="Analytics의 필요성"></a>Analytics의 필요성</h2><p>iOS앱을 만들어서 많은 사용자를 보유하려면 사용자가 어떤 기능을 좋아하는지(얼마나 많이 사용하는지), 사용하지 않는 기능은 무엇인지(사용률이 적은 기능)이 무엇인지 알고 계속 개선해 나가야 합니다. 하지만 iOS앱은 AppStore에 업로드하면 개발자의 손을 떠나게 됩니다.</p><p>그렇다면 사람들이 어떤 기능을 자주 쓰는지, 필요로 하는지 어떻게 수집을 할까요?<br><code>지표 수집</code>툴을 사용합니다. 대표적으로는 <a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a>가 있습니다. 그 외에도 <a href="https://www.toast.com/" target="_blank" rel="noopener">Toast Analytics</a>, <a href="https://www.userhabit.io/ko" target="_blank" rel="noopener">UserHabbit</a> 등 다른 지표수집 툴도 많이 있습니다</p><p>이번에 Swift 스터디를 하면서 만들었던 앱에 Google Analytics를 연동해보면서 기록을 정리해서 남깁니다.</p><h2 id="Google-Analytics-가입하기"><a href="#Google-Analytics-가입하기" class="headerlink" title="Google Analytics 가입하기"></a>Google Analytics 가입하기</h2><p><a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a> 에 접속후 로그인합니다. 계정은 구글계정으로 사용합니다.</p><p><img src="../../../../images/ga/1.png" alt=""><br>지표수집에 사용할 앱 or 웹을 등록합니다. 기존에 사용하던 앱 2개가 있어서 위와 같은 페이지로 뜨는데, <code>관리</code> 쪽 메뉴에서 새로운 앱을 등록할 수 있습니다. 이름이 <code>계정 만들기</code>로 되어있어요.</p><p><img src="../../../../images/ga/2.png" alt=""><br>iOS 앱의 지표수집에 사용할 것으로 <code>모바일 앱</code>을 선택 후 계정이름과, 앱이름을 설정합니다.<br>데이터 공유 설정은 잘 읽어보시고 선택하시고, 모르겠다 싶으면 전체선택하셔도 괜찮습니다.<br>모두 작성 완료 후 가장 아래에 <code>추적 ID 가져오기</code>를 클릭합니다.</p><p><img src="../../../../images/ga/3.png" alt=""><br>애널리틱스 서비스 약관동의 팝업이 뜹니다. 요즘 GDPR 관련돼서 이슈가 많은데요. GDPR 관련해서는 따로 <code>꼭</code> 확인해주세요.<br>동의함을 눌러주세요.</p><p><img src="../../../../images/ga/4.png" alt=""><br>앱 등록이 완료되면 위와 같은 화면이 나옵니다. 이 화면에서 필요한 것은!! <code>추적 ID</code> 입니다. 복사해두세요~</p><h2 id="iOS에-Google-Analytics-적용하기"><a href="#iOS에-Google-Analytics-적용하기" class="headerlink" title="iOS에 Google Analytics 적용하기"></a>iOS에 Google Analytics 적용하기</h2><h3 id="Pod-install"><a href="#Pod-install" class="headerlink" title="Pod install"></a>Pod install</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;GoogleAnalytics&apos;</span><br></pre></td></tr></table></figure><p>사용중인 프로젝트의 Podfile에 <code>GoogleAnanytics</code> Pod 을 추가, 설치해줍니다.</p><p>cocoaPod사용법은 아래 포스팅을 참고해주세요.<br><a href="http://monibu1548.github.io/2018/04/16/cocoapods/">iOS 프로젝트에 cocoapods 적용하기</a><br><a href="http://monibu1548.github.io/2018/04/16/cocoapods-prompt/">CocoaPods 똑똑하게 사용하기 (명령어, 사용 예시 소개)</a></p><h3 id="AppDelegate-설정"><a href="#AppDelegate-설정" class="headerlink" title="AppDelegate 설정"></a>AppDelegate 설정</h3><p>아쉽게도 아직 <code>Swift</code> 에서는 Object-c bridge를 통해 사용합니다. 번거로워요.<br>object-bridge 는 다음 블로그를 확인해주세요 <a href="https://m.blog.naver.com/PostView.nhn?blogId=seotaji&amp;logNo=220312825002&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F" target="_blank" rel="noopener">애플 스위프트(Apple Swift) Bridging-Header.h 생성하기</a></p><p>그리고 AppDelegate의 didFinishLaunchingWithOptions메소드에 아까 발급받은 Tracking ID(추적 ID)를 등록합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    gai.tracker(withTrackingId: <span class="string">"YOUR_TRACKING_ID"</span>)  <span class="comment">// 발급받은 트래킹 ID를 넣어주세요</span></span><br><span class="line">    <span class="comment">// Optional: automatically report uncaught exceptions.</span></span><br><span class="line">    gai.trackUncaughtExceptions = <span class="literal">true</span>   <span class="comment">// 앱 크래시 발생 내역도 수집을 할 것인지 선택하는 옵션입니다.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Optional: set Logger to VERBOSE for debug information.</span></span><br><span class="line">    <span class="comment">// Remove before app release.</span></span><br><span class="line">    gai.logger.logLevel = .verbose;  <span class="comment">// 로그레벨을 결정합니다. 앱스토어 배포용에서는 이 옵션을 꼭 제거해주세요</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>주의할 점</code></p><ul><li>우리가 원하는 것은 이 앱의 사용자들이 앱을 사용하는 방식에 대한 데이터입니다. 위의 코드를 개발단계에서 사용할 경우 앱을 개발하는 과정에서의 지표도 수집되기 때문에 유효한 데이터를 수집할 수 없습니다.</li><li>유효한 데이터만 수집하기 위해서는 아래의 방식을 따릅니다<ul><li>개발용, 배포용 Analytics를 각각 만들어서 빌드 config에 따라 트래킹 ID를 바꿔치기 합니다.</li><li>사실 개발용은 지표수집의 의미가 없기 때문에 Debug config에서는 트래킹 ID 를 비워도 됩니다.</li></ul></li></ul><h2 id="수집할-지표의-결정"><a href="#수집할-지표의-결정" class="headerlink" title="수집할 지표의 결정"></a>수집할 지표의 결정</h2><p>AppDelegate에 트래킹 ID 등록까지 끝났다면, 사용준비는 끝났습니다. 이제 수집하고 싶은 데이터의 위치에 수집코드만 넣어주면 됩니다.</p><h3 id="화면-정보-수집"><a href="#화면-정보-수집" class="headerlink" title="화면 정보 수집"></a>화면 정보 수집</h3><p>아마 무조건 사용하는 정보일겁니다. 사용자가 어떤 화면에 얼마나 많이, 오래 진입했는지의 정도를 알 수 있는 지표입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        super.viewWillAppear(animated)</span><br><span class="line">        guard let tracker = GAI.sharedInstance().defaultTracker else &#123; return &#125;</span><br><span class="line">        tracker.set(kGAIScreenName, value: &quot;메인&quot;)</span><br><span class="line">        </span><br><span class="line">        guard let builder = GAIDictionaryBuilder.createScreenView() else &#123; return &#125;</span><br><span class="line">        tracker.send(builder.build() as [NSObject : AnyObject])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>화면 정보를 수집할 뷰컨트롤러의 <code>viewWillAppear</code>에 위의 코드를 넣어줍니다.<br><code>tracker.set()</code> 의 value에는 화면 이름을 입력합니다.<br>이제 사용자가 해당 화면에 진입하면 해당 화면정보가 수집됩니다.</p><h3 id="이벤트-정보-수집"><a href="#이벤트-정보-수집" class="headerlink" title="이벤트 정보 수집"></a>이벤트 정보 수집</h3><p>화면 수집 다음으로 유용한 지표입니다. 사용자가 특정 버튼을 얼마나 눌렀는지, 사용빈도를 알 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private func getVoca() -&gt; Voca? &#123;</span><br><span class="line">        </span><br><span class="line">        let tracker = GAI.sharedInstance().defaultTracker</span><br><span class="line">        tracker?.send(GAIDictionaryBuilder.createEvent(withCategory: &quot;단어 퀴즈&quot;, action: &quot;문제 Go&quot;, label: &quot;문제 출제&quot;, value: nil).build() as [NSObject : AnyObject])</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        // ... 문제 출제 로직 ... </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>위 코드는 특정 버튼을 눌렀을때 해당 이벤트를 수집하는 코드입니다. 카테고리, 액션, 라벨 3단계로 구분되어 개발자가 서비스에 맞게 사용하면 됩니다.</p><p><img src="../../../../images/ga/5.png" alt=""><br><img src="../../../../images/ga/6.png" alt=""></p><p>테스트를 해보면 다음과 같은 화면이 뜹니다. 현재 실시간 사용자, 화면, 앱버전, 위치 등 다양한 정보를 볼 수 있습니다!</p>]]></content>
    
    <summary type="html">
    
      Analytics의 필요성
iOS앱을 만들어서 많은 사용자를 보유하려면 사용자가 어떤 기능을 좋아하는지(얼마나 많이 사용하는지), 사용하지 않는 기능은 무엇인지(사용률이 적은 기능)이 무엇인지 알고 계속 개선해 나가야 합니다. 하지만 iOS앱은 AppStore에 업로드하면 개발자의 손을 떠나게 됩니다.

그렇다면 사람들이 어떤 기능을 자주 쓰는지, 필요로 하는지 어떻게 수집을 할까요?
지표 수집툴을 사용합니다. 대표적으로는 Google Analytics가 있습니다. 그 외에도 Toast Analytics, UserHabbit 등 다
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="구글 애널리틱스" scheme="http://monibu1548.github.io/tags/%EA%B5%AC%EA%B8%80-%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B1%EC%8A%A4/"/>
    
      <category term="지표수집" scheme="http://monibu1548.github.io/tags/%EC%A7%80%ED%91%9C%EC%88%98%EC%A7%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS앱 고도화 - Firebase Remote Config를 사용한 앱 운영방법</title>
    <link href="http://monibu1548.github.io/2018/05/14/firebase-config/"/>
    <id>http://monibu1548.github.io/2018/05/14/firebase-config/</id>
    <published>2018-05-14T12:14:04.000Z</published>
    <updated>2018-05-29T12:04:49.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Firebase-Remote-Config"><a href="#Firebase-Remote-Config" class="headerlink" title="Firebase Remote Config"></a>Firebase Remote Config</h2><p>Firebase Remote Config란, 앱 업데이트를 게시하지 않고도 앱의 동작과 모양을 변경할 수 있도록 도와주는 서비스입니다. 앱의 실행시점에 서버에서 Config를 읽어오는 비교적 쉬운 개념이지만. 이를 활용해서 다양한 응용동작을 할 수 있습니다.</p><p>비슷한 서비스로는 NHN Entertainment의 Toast Cloud - Launching이 있습니다.</p><ol><li>최신 업데이트 버전을 가져와 현재 설치된 버전과 비교하여 업데이트를 유도할 수 있습니다.</li><li>공지사항 팝업을 띄울 수 있습니다.</li><li>Color 값을 전달하면 앱의 전반전인 테마 컬러 변경이 가능합니다.</li><li>static한 문구들 (연도, 전화번호)을 변경할 때 앱을 새로 빌드할 필요가 없습니다.</li></ol><p>이 기능을 구현하려면 Config 정보를 내려줄 서버가 필요합니다. 하지만 단일 앱 개발자에게 서버는 사치죠ㅜㅠ</p><p>고맙게도 Google의 Firebase에서 이러한 기능을 제공합니다. <code>Remote Config</code> 라는 이름으로 위 기능을 제공하고 있습니다.</p><h2 id="Firebase-시작하기"><a href="#Firebase-시작하기" class="headerlink" title="Firebase 시작하기"></a>Firebase 시작하기</h2><p><a href="https://firebase.google.com/?authuser=0" target="_blank" rel="noopener">Google Firebase 홈페이지</a></p><p><img src="../../../../images/firebaseconfig/1.png" alt=""></p><p>프로젝트 생성 후 <code>Remote Config</code> 시작하기를 클릭합니다.</p><p><img src="../../../../images/firebaseconfig/2.png" alt=""><br>이제 매개변수를 설정할 수 있습니다.</p><p><img src="../../../../images/firebaseconfig/3.png" alt=""><br>버전, 광고 실행 유무 등, 앱애서 사용할 매개변수들을 추가합니다.</p><p><img src="../../../../images/firebaseconfig/4.png" alt=""><br><code>변경사항 개시</code> 버튼을 클릭하여 해당 내용을 배포합니다.</p><h2 id="iOS에서-Firebase-Remote-Config-설정하기"><a href="#iOS에서-Firebase-Remote-Config-설정하기" class="headerlink" title="iOS에서 Firebase Remote Config 설정하기"></a>iOS에서 Firebase Remote Config 설정하기</h2><p><a href="https://firebase.google.com/docs/remote-config/use-config-ios?authuser=0" target="_blank" rel="noopener">공식 가이드 문서 링크</a></p><h2 id="GoogleService-Info-plist"><a href="#GoogleService-Info-plist" class="headerlink" title="GoogleService-Info.plist"></a>GoogleService-Info.plist</h2><p>iOS앱에서 Firebase에 연결하기 위해서는 <code>GoogleService-Info.plist</code> 가 필요하며. 이 파일은 Firebase에서 제공합니다.</p><p><img src="../../../../images/firebaseconfig/5.png" alt=""><br>Firebase에서 프로젝트를 생성합니다.</p><p><img src="../../../../images/firebaseconfig/6.png" alt=""><br>프로젝트에서 사용하고있는 Firebase 서비스의 정보를 담긴 <code>GoogleService-Info.plist</code>를 다운받습니다.<br>나중에 Cloude Message 등 다른 추가기능 사용을 선택하면 <code>GoogleService-Info.plist</code> 업데이트도 필요합니다.</p><h3 id="Pod-설치"><a href="#Pod-설치" class="headerlink" title="Pod 설치"></a>Pod 설치</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Firebase/RemoteConfig&apos;</span><br></pre></td></tr></table></figure><p>Podfile에 추가 후 설치합니다.</p><h3 id="AppDelegate-설정"><a href="#AppDelegate-설정" class="headerlink" title="AppDelegate 설정"></a>AppDelegate 설정</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Firebase/RemoteConfig</span><br></pre></td></tr></table></figure><p>사용하고 있는 AppDelegate에 RemoteConfig 모듈을 추가합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;</span><br><span class="line">        FirebaseApp.configure()</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>didFinishLaunchingWithOptions</code> 메소드에  Firebase.configure()를 추가하여 공유 인스턴스를 구성합니다.</p><p><img src="../../../../images/firebaseconfig/7.png" alt=""></p><p>fetch 과정을 통해 Firebase에 등록했던 매개변수들이 정상적으로 내려오는지 확인해봅니다.</p>]]></content>
    
    <summary type="html">
    
      Firebase Remote Config
Firebase Remote Config란, 앱 업데이트를 게시하지 않고도 앱의 동작과 모양을 변경할 수 있도록 도와주는 서비스입니다. 앱의 실행시점에 서버에서 Config를 읽어오는 비교적 쉬운 개념이지만. 이를 활용해서 다양한 응용동작을 할 수 있습니다.

비슷한 서비스로는 NHN Entertainment의 Toast Cloud - Launching이 있습니다.

 1. 최신 업데이트 버전을 가져와 현재 설치된 버전과 비교하여 업데이트를 유도할 수 있습니다.
 2. 공지사항 팝업을 띄울 
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Firebase" scheme="http://monibu1548.github.io/tags/Firebase/"/>
    
      <category term="앱 고도화" scheme="http://monibu1548.github.io/tags/%EC%95%B1-%EA%B3%A0%EB%8F%84%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>Storyboard autolayout 환경에서 Keyboard Event로 Height 처리하기</title>
    <link href="http://monibu1548.github.io/2018/05/14/keyboard-autolayout-event/"/>
    <id>http://monibu1548.github.io/2018/05/14/keyboard-autolayout-event/</id>
    <published>2018-05-13T15:03:38.000Z</published>
    <updated>2018-05-29T12:05:08.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Text-Input이-필요한-화면에서-고려할점"><a href="#Text-Input이-필요한-화면에서-고려할점" class="headerlink" title="Text Input이 필요한 화면에서 고려할점"></a>Text Input이 필요한 화면에서 고려할점</h2><p>TextView 또는 TextField를 이용해 사용자로부터 텍스트를 입력받는 화면에서는 <code>키보드</code>가 나타납니다.<br><code>키보드</code>가 나타나면 그만큼 컨텐츠를 보여줄 수 있는 화면의 Height는 줄어들게 되고 그 중 일부는 키보드 밑으로 말려들어가 보이지 않게 되는 문제가 생길 수 있습니다.<br>따라서 키보드가 나타날 때 아래의 뷰를 키보드 위로 올려주는 구현이 필요합니다.</p><h2 id="왜-키보드는-Autolayout-Bottom-Layout에-걸리지-않는가…"><a href="#왜-키보드는-Autolayout-Bottom-Layout에-걸리지-않는가…" class="headerlink" title="왜 키보드는 Autolayout Bottom Layout에 걸리지 않는가…"></a>왜 키보드는 Autolayout Bottom Layout에 걸리지 않는가…</h2><p>스토리보드와 오토레이아웃을 사용하면서 iOS 11 이후 등장한 <code>SafeArea</code>에 대한 대응이 편해졌습니다.<br>처음에는 당연히 키보드가 나타날 때 <code>Bottom Layout Guide</code>가 올라오면서 자동으로 대응이 될 거라고 생각했지만…. 중요한 문구, 버튼들이 키보드 밑으로 말려들어가는 대참사가 발생했습니다.</p><h2 id="Notification과-Autolayout을-이용해-간단하게-해결"><a href="#Notification과-Autolayout을-이용해-간단하게-해결" class="headerlink" title="Notification과 Autolayout을 이용해 간단하게 해결"></a>Notification과 Autolayout을 이용해 간단하게 해결</h2><p>iOS가 오토레이아웃을 해주지 않는다면 Keyboard 사이즈의 View를 직접 넣어 Autolayout으로 동작하게 만들고,<br>Notification을 이용해 keyboard 상태를 받아 Keyboard layout을 대신하는 View의 Height를 조작함으로써 수정했습니다.</p><p><img src="../../../../images/keyboard/1.png" alt=""></p><p>Keyboard가 나타날 수 있는 ViewController의 가장 하단에 View를 하나 끼워넣습니다.<br>이 View는 키보드의 show, dismiss 동일한 타이밍, 사이즈로 동작하게 만들겁니다.</p><p>Contraint를 이용해 topAnchor를 기존에 가장 하단에 있던 뷰의 bottomAnchor에 연결하고, bottomAnchor는 viewController의 root view의 bottom layout guide에 연결해줍니다.<br>그리고 height는 키보드와 동일한 값을 갖게 할거고 초기값은 0으로 설정해줍니다.(키보드 없는상태)</p><p>이제 <code>Notification</code>을 이용해 이 View의 height를 조절하면 됩니다.</p><h2 id="Keyboard-Notification-Register"><a href="#Keyboard-Notification-Register" class="headerlink" title="Keyboard Notification Register"></a>Keyboard Notification Register</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TranslationViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">initializeKeyboardEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(keyBoardWillShow(notification:)), name: .<span class="type">UIKeyboardWillShow</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(keyBoardWillHide(notification:)), name: .<span class="type">UIKeyboardWillHide</span>, object: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">removeKeyboardEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">keyBoardWillShow</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> userInfo:<span class="type">NSDictionary</span> = notification.userInfo! <span class="keyword">as</span> <span class="type">NSDictionary</span></span><br><span class="line">        <span class="keyword">let</span> keyboardFrame:<span class="type">NSValue</span> = userInfo.value(forKey: <span class="type">UIKeyboardFrameEndUserInfoKey</span>) <span class="keyword">as</span>! <span class="type">NSValue</span></span><br><span class="line">        <span class="keyword">let</span> keyboardRectangle = keyboardFrame.cgRectValue</span><br><span class="line">        <span class="keyword">let</span> keyboardHeight = keyboardRectangle.height</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.keyboardHeightConstraint.constant = keyboardHeight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">keyBoardWillHide</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.keyboardHeightConstraint.constant = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 Keyboard Notification 관련 로직을 처리하기 위해 extension으로 분리한 controller입니다.</p><ul><li>initializeKeyboardEvent : Keyboard의 Show, Hide 이벤트를 받기위해 Notification Center에 옵저버를 등록합니다.</li><li>keyBoardWillShow : Keyboard가 나타날때 호출되며 notification 객체에서 keyboard height 가져올 수 있습니다. </li><li>keyBoardWillHide : Keyboard가 사라질때 호출됩니다.</li><li>removeKeyboardEvent : Notification을 더 이상 사용하지 않을 때 옵저버를 제거합니다.</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TranslationViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.initializeKeyboardEvent()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.removeKeyboardEvent()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extension에서 구현했던 Nofitication관련 메소드들을 호출하는 메인 뷰컨트롤러입니다.</p><p>키보드를 사용하는 뷰 컨트롤러가 많지는 않지만, 추가될 때마다 이 작업을 계속해야 할 텐데, 아예 상속받을 뷰 컨트롤러을 하나 만들어 주는 것도 좋을 것 같습니다.</p>]]></content>
    
    <summary type="html">
    
      Text Input이 필요한 화면에서 고려할점
TextView 또는 TextField를 이용해 사용자로부터 텍스트를 입력받는 화면에서는 키보드가 나타납니다.
키보드가 나타나면 그만큼 컨텐츠를 보여줄 수 있는 화면의 Height는 줄어들게 되고 그 중 일부는 키보드 밑으로 말려들어가 보이지 않게 되는 문제가 생길 수 있습니다.
따라서 키보드가 나타날 때 아래의 뷰를 키보드 위로 올려주는 구현이 필요합니다.

왜 키보드는 Autolayout Bottom Layout에 걸리지 않는가…
스토리보드와 오토레이아웃을 사용하면서 iOS 11 이
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="오토레이아웃" scheme="http://monibu1548.github.io/tags/%EC%98%A4%ED%86%A0%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83/"/>
    
  </entry>
  
  <entry>
    <title>[Swift] Date to String, Date &lt;=&gt; String 객체간 변환</title>
    <link href="http://monibu1548.github.io/2018/05/13/string-date-convert/"/>
    <id>http://monibu1548.github.io/2018/05/13/string-date-convert/</id>
    <published>2018-05-13T11:05:40.000Z</published>
    <updated>2018-05-13T11:18:55.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String과-Date의-객체간-변환"><a href="#String과-Date의-객체간-변환" class="headerlink" title="String과 Date의 객체간 변환"></a>String과 Date의 객체간 변환</h1><p>Date와 String의 변환은 매우 자주 사용하면서도 할 때마다 뭐였지 하고 다시 찾아보곤 합니다.<br>또 Obj-C만 사용하다가 Swift로 넘어오면서 한번 정리하고 갑니다. 참고로 swift4 입니다</p><h2 id="String-gt-Date"><a href="#String-gt-Date" class="headerlink" title="String -&gt; Date"></a>String -&gt; Date</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateString:<span class="type">String</span> = <span class="string">"2018-05-13 15:05:40"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line"></span><br><span class="line">dateFormatter.dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span></span><br><span class="line">dateFormatter.timeZone = <span class="type">NSTimeZone</span>(name: <span class="string">"UTC"</span>) <span class="keyword">as</span> <span class="type">TimeZone</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date:<span class="type">Date</span> = dateFormatter.date(from: dateString)!</span><br></pre></td></tr></table></figure><p>Obj-C 와 마찬가지로 <code>DateFormatter</code>를 이용합니다.<br>DateFormatter에 날짜 형식화 타임존을 설정 후 String을 dateFormatter의 <code>date</code> 메소드를 이용해 변환합니다.</p><h2 id="Date-gt-String"><a href="#Date-gt-String" class="headerlink" title="Date -&gt; String"></a>Date -&gt; String</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date:<span class="type">Date</span> = <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">dateFormatter.dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dateString:<span class="type">Date</span> dateFormatter.string(from: date)</span><br></pre></td></tr></table></figure><p>DateFormatter의 <code>string</code> 메소드를 사용하여 변환 가능합니다.</p>]]></content>
    
    <summary type="html">
    
      String과 Date의 객체간 변환
Date와 String의 변환은 매우 자주 사용하면서도 할 때마다 뭐였지 하고 다시 찾아보곤 합니다.
또 Obj-C만 사용하다가 Swift로 넘어오면서 한번 정리하고 갑니다. 참고로 swift4 입니다

String -&gt; Date
1
2
3
4
5
6
7
8
9



let dateString:String = &quot;2018-05-13 15:05:40&quot;

let dateFormatter = DateFormatter()

dateFormatter.dateFormat = &quot;yyyy-MM-dd HH:mm:
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Swift" scheme="http://monibu1548.github.io/categories/iOS/Swift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://monibu1548.github.io/tags/Swift/"/>
    
      <category term="스위프트" scheme="http://monibu1548.github.io/tags/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>[Swift] Optional이란? 옵셔널 이해하기</title>
    <link href="http://monibu1548.github.io/2018/05/12/swift-optional/"/>
    <id>http://monibu1548.github.io/2018/05/12/swift-optional/</id>
    <published>2018-05-12T06:41:46.000Z</published>
    <updated>2018-05-12T08:33:21.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Swift가 갖는 Optional이라는 개념은 변수의 값이 <code>nil</code>일 수 있다는 것을 표현하는 건데요, 반대로 Optional이 아니라면(non-optional) 해당 값은 <code>nil</code>이 될 수 없음을 의미합니다. Objective-C를 사용해왔다면 Optional이라는 표현이 너무나도 당연해보일 수 있지만, Swift에서는 Optional은 말 그대로 <code>옵션(선택적)</code> 이며 기본값은 non-Optional 입니다.</p><h2 id="선언"><a href="#선언" class="headerlink" title="선언"></a>선언</h2><p>Optional 변수의 선언은 <code>?</code> 키워드를 사용합니다<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String</span>?</span><br></pre></td></tr></table></figure></p><p>Optional의 디폴트 값은 <code>nil</code>로 name은 <code>nil</code>을 갖게 됩니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> <span class="comment">// 컴파일에러</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="literal">nil</span> <span class="comment">// 컴파일에러</span></span><br></pre></td></tr></table></figure><p>만약 Optional 키워드를 사용하지 않았다면 값을 입력하라는 에러가 발생하고, 그 이후에라도 nil을 넣으려하면 컴파일에러가 발생합니다.<br>여기에서 Swift가 기본적으로 non-optional을 지원하면서 갖는 <code>엄청난 장점</code>을 느낄 수 있습니다.<br>nil에 대한 컴파일 에러를 통해 개발자는 nil에 대해 명확한 예외처리가 강제되며, 런타임에 nil로 인한 문제를 <code>컴파일 단계</code>에서 예방할 수 있습니다.</p><p>그래서 Swift가 잠재적 오류에 대해 안전하다고 표현하는 글도 많이 있습니다.</p><h2 id="Optional-변수의-이용"><a href="#Optional-변수의-이용" class="headerlink" title="Optional 변수의 이용"></a>Optional 변수의 이용</h2><p>Optional변수는 <code>nil</code>을 가질 수 있는 특별한 변수입니다. Optional 변수를 이용해서 작업할 때 Optional을 해제하는 과정이 추가적으로 필요합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var number1:Int? = 20</span><br><span class="line">var number2:Int = 100</span><br><span class="line"></span><br><span class="line">number1 + number2</span><br></pre></td></tr></table></figure></p><p>Int(optional)와 Int(non-optional)의 연산을 시도하면<br><code>Value of optional type &#39;Int?&#39; not unwrapped; did you mean to use &#39;!&#39; or &#39;?&#39;?</code></p><p>위 컴파일 에러가 발생합니다.<br>number1은 Optional로 nil값을 가질 <code>가능성</code>이 있기 때문에 컴파일 단계에서 에러를 발생시킵니다. 연산을 수행하기 위해서는 <code>unwrapping</code> 또는 <code>binding</code> 과정이 필요합니다.</p><h3 id="Optional-Unwrapping-옵셔널-해제"><a href="#Optional-Unwrapping-옵셔널-해제" class="headerlink" title="Optional Unwrapping (옵셔널 해제)"></a>Optional Unwrapping (옵셔널 해제)</h3><p>Optional Unwrapping이란 Optional 변수에서 Optional 껍데기를 벗겨내는 작업입니다. </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number1:<span class="type">Int</span>? = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> number2:<span class="type">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number1 &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = number1! + number1!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 로 optional 변수의 값이 nil이 아닌지 판별 후 <code>!</code> unwrapping 키워드를 통해 강제로 값을 꺼내옵니다. 만약 if로 nil 체크를 하지 않고 <code>!</code>을 사용한다면 런타임 오류가 발생할 수 있습니다.</p><h3 id="Optional-Binding-옵셔널-바인딩"><a href="#Optional-Binding-옵셔널-바인딩" class="headerlink" title="Optional Binding (옵셔널 바인딩)"></a>Optional Binding (옵셔널 바인딩)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var number1:Int? = 20</span><br><span class="line">var number2:Int = 100</span><br><span class="line"></span><br><span class="line">if let nonOptionalNumber1 = number1 &#123;</span><br><span class="line">    let sum = nonOptionalNumber1 + number2</span><br></pre></td></tr></table></figure><p>Optional Unwrapping과 비슷하지만 Optional 값을 새로운 상수로 받고, 그 이후로 non-optional값을 사용한다는 차이점이 있다.<br>새로 선언된 nonOptionalNumber1은 이미 non-optional로 연산에 사용할 때 <code>!</code> 키워드를 사용할 필요가 없다.</p><h2 id="Optional-Chaining-옵셔널-체이닝"><a href="#Optional-Chaining-옵셔널-체이닝" class="headerlink" title="Optional Chaining (옵셔널 체이닝)"></a>Optional Chaining (옵셔널 체이닝)</h2><p>여러 객체를 혼합해서 사용하다보면 Optional끼리의 연산이 필요한 경우가 있습니다. 이 경우에 객체마다 옵셔널 바인딩을 사용하게 되면, if문이 꽤나 복잡해지겠죠<br>Optional Chaining을 통해서 좀 더 간단하게 Optional 예외처리를 할 수 있습니다.</p><p>swift에서 <code>.</code> 을 통해 클래스의 프로퍼티에 접근이 가능합다는 점을 이용합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b:<span class="type">B</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">c</span>:<span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 경우 A의 프로퍼티 b의 c에 접근할 때, b에대한 옵셔널, c에대한 옵셔널, 2번의 바인딩이 필요합니다.<br>이 경우에 옵셔널 체이닝을 통해 한줄로 옵셔널 바인딩이 가능합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">A</span> = <span class="type">A</span>()</span><br><span class="line"><span class="keyword">if</span> a.b?.<span class="built_in">c</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>a.b?.c</code> 를 통해 b의 옵셔널, c의 옵셔널 바인딩을 모두 처리가능합니다.</p><h2 id="Optional이-점점-불편해-보이는데-왜-사용할까"><a href="#Optional이-점점-불편해-보이는데-왜-사용할까" class="headerlink" title="Optional이 점점 불편해 보이는데 왜 사용할까?"></a>Optional이 점점 불편해 보이는데 왜 사용할까?</h2><p>Objective-C에는 아직 <code>nil</code>타입이 존재하며 하나의 프로젝트에서 obj-c와 swift를 혼용해서 사용할 수 있습니다. 따라서 obj-c와의 상호운용성을 위해 사용합니다.</p>]]></content>
    
    <summary type="html">
    
      Optional
Swift가 갖는 Optional이라는 개념은 변수의 값이 nil일 수 있다는 것을 표현하는 건데요, 반대로 Optional이 아니라면(non-optional) 해당 값은 nil이 될 수 없음을 의미합니다. Objective-C를 사용해왔다면 Optional이라는 표현이 너무나도 당연해보일 수 있지만, Swift에서는 Optional은 말 그대로 옵션(선택적) 이며 기본값은 non-Optional 입니다.

선언
Optional 변수의 선언은 ? 키워드를 사용합니다
1


var name: String?




Op
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Swift" scheme="http://monibu1548.github.io/categories/iOS/Swift/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://monibu1548.github.io/tags/Swift/"/>
    
      <category term="스위프트" scheme="http://monibu1548.github.io/tags/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS 앱에서 광고 수익 얻기 (Admob 애드몹 설치, 부착, 예제)</title>
    <link href="http://monibu1548.github.io/2018/05/06/ios-admob/"/>
    <id>http://monibu1548.github.io/2018/05/06/ios-admob/</id>
    <published>2018-05-05T18:30:43.000Z</published>
    <updated>2018-05-29T12:05:04.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="앱을-다-만들었다면-수익에-도전해보자"><a href="#앱을-다-만들었다면-수익에-도전해보자" class="headerlink" title="앱을 다 만들었다면 수익에 도전해보자"></a>앱을 다 만들었다면 수익에 도전해보자</h2><p>모바일 어플리케이션에 광고를 부착할 수 있는 다양한 플랫폼이 있다. 그중에서도 Google의 Admob을 이용한 방법을 소개합니다.</p><h2 id="Admob-가입하기"><a href="#Admob-가입하기" class="headerlink" title="Admob 가입하기"></a>Admob 가입하기</h2><p><a href="https://www.google.co.kr/admob" target="_blank" rel="noopener">https://www.google.co.kr/admob</a> 구글 애드몹 페이지</p><p>구글 계정으로 로그인 할 수 있습니다.</p><h2 id="광고-생성하기"><a href="#광고-생성하기" class="headerlink" title="광고 생성하기"></a>광고 생성하기</h2><p>우선 애드몹 페이지에서 광고를 붙일 앱을 설정합니다. <code>앱 추가</code> 버튼을 통해 추가할 수 있습니다.</p><p><img src="../../../../images/admob/1.png" alt=""><br>광고를 부착할 앱이 기존에 스토어에 등록되어있던 앱인지, 새로 만들 앱인지 선택합니다. 저는 아직 스토어에 업로드 하지 않아서 <code>아니요</code>를 선택했습니다.</p><p><img src="../../../../images/admob/2.png" alt=""><br>앱의 이름(스토어에 노출되는 이름은 아니고, Admob에서 구분하기 위한 별명같은 용도로 사용됩니다.)과 플랫폼을 선택합니다.</p><p><img src="../../../../images/admob/3.png" alt=""><br>앱을 생성하면 앱 리스트에 노출되며, 앱이름을 클릭해서 더 상세한 설정을 할 수 있습니다.</p><p><img src="../../../../images/admob/4.png" alt=""><br>광고 단위 만들기 버튼을 통해 광고 단위를 생성합니다.</p><p><img src="../../../../images/admob/5.png" alt=""><br>현재 배너, 전면, 리워드 이렇게 3가지 광고 타입을 제공합니다. 앱의 사용성을 선택해서 선택하면 되는데, 저는 배너를 사용했습니다.</p><p><img src="../../../../images/admob/6.png" alt=""><br>광고 단위 이름을 입력해줍니다.</p><p><img src="../../../../images/admob/7.png" alt=""><br>광고 단위가 생성되었습니다. 이제 AppID와 UnitID를 통해 앱에 광고를 부착할 수 있습니다.<br>이 페이지에서 2개의 ID값을 볼 수 있는데요, 위에가 AppID, 아래가 UnitID입니다.</p><ul><li>AppID : 앱의 Identifier, AppDelegate.m 에서 설정에 필요</li><li>UnitID : 배너 광고를 띄울 뷰컨트롤러 설정에 필요</li></ul><h2 id="CocoaPods-설치"><a href="#CocoaPods-설치" class="headerlink" title="CocoaPods 설치"></a>CocoaPods 설치</h2><p>이제 앱에 배너광고를 설치합니다.<br><code>Podfile</code>에 아래 Pod를 추가하고 <code>Pod install</code>을 통해 SDK를 설치합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Google-Mobile-Ads-SDK&apos;</span><br></pre></td></tr></table></figure><h2 id="App-Delegate-설정"><a href="#App-Delegate-설정" class="headerlink" title="App Delegate 설정"></a>App Delegate 설정</h2><p>AppDelegate.m 파일을 열어주세요.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;GoogleAnalytics/GAI.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>위 헤더파일이 필요합니다.</p><p>아래 코드와 같이 <code>didFinishLaunchingWithOptions</code> 메소드에 애드몹을 설정하는 코드를 추가합니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    </span><br><span class="line">    [GADMobileAds configureWithApplicationID:<span class="string">@"애드몹AppId"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Banner-영역-설정하기"><a href="#Banner-영역-설정하기" class="headerlink" title="Banner 영역 설정하기"></a>Banner 영역 설정하기</h2><p><img src="../../../../images/admob/8.png" alt=""></p><p>스토리보드에서 Banner영역을 잡아줍니다.<br>저는 화면 아래쪽에 배치했습니다. Banner의 Size는 <code>320 * 50</code>으로 지정해주셔야합니다. 그리고 그 View 의 CustomClass를 <code>GADBannerView</code>로 설정합니다.</p><p>이제 코드영역에서 해당 뷰에 UnitID를 지정해줘야 합니다. 이 작업은 <code>ViewDidLoad</code> 에서 작업합니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.bannerView.adUnitID = admobBannerUnitId;</span><br><span class="line"><span class="keyword">self</span>.bannerView.rootViewController = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.bannerView loadRequest:[GADRequest request]];</span><br></pre></td></tr></table></figure><p>여기에서 self.bannerView는 스토리보드에서 IBOutlet으로 가져온 GADBannerView 입니다.<br><code>admobBannerUnitId</code> 을 발급받은 UnitID로 변경합니다.</p><ul><li>추가적으로, bannerView에 델리게이트를 지정하여 광고를 성공적으로 가져왔는지, 문제가 있는지 등의 결과를 받을 수 있습니다. 해당내용은 아래에 링크합니다.<br><a href="https://developers.google.com/admob/ios/banner" target="_blank" rel="noopener">https://developers.google.com/admob/ios/banner</a></li></ul><h2 id="Test-광고-붙여보기"><a href="#Test-광고-붙여보기" class="headerlink" title="Test 광고 붙여보기"></a>Test 광고 붙여보기</h2><p>위 과정까지 진행하고 앱을 실행시켜보면 광고가 뜨지 않습니다. 왜냐하면 <code>Debug</code> 모드에서는 광고가 노출되지 않기 때문이죠. 그러면 어떻게 광고가 잘 노출되는지 확인할 수 있을까요.<br>ADMob에서는 테스트 광고를 제공합니다.</p><p>발급받은 AppID와 UnitID중에서 UnitID를 <code>ca-app-pub-3940256099942544/6300978111</code> 로 변경합니다.</p><p>위 테스트 UnitID는 배너 타입의 광고에만 유효하며 그 외 타입은 다음 링크를 참고해주세요.<br><a href="https://developers.google.com/admob/android/test-ads" target="_blank" rel="noopener">https://developers.google.com/admob/android/test-ads</a></p><p>이제 앱을 다시 실행해보면 테스트 광고가 노출되는 것을 확인할 수 있습니다.</p><ul><li>빌드 과정에서 <code>Release</code> config로 빌드하는 경우 실제 UnitID를 사용하고, <code>Debug</code>로 빌드하는 경우 테스트용 UnitID를 사용하게 설정해두면 편합니다!</li></ul><h2 id="더-나아가서"><a href="#더-나아가서" class="headerlink" title="더 나아가서"></a>더 나아가서</h2><p>ADMob에서는 더 다양한 기능을 제공합니다.<br>예를들면 광고를 불러오기 전까지는 배너 영역을 갖고있지 않다가, 광고를 받아오면 해당 배너영역을 확장시켜 보여줄 수도 있습니다.</p>]]></content>
    
    <summary type="html">
    
      앱을 다 만들었다면 수익에 도전해보자
모바일 어플리케이션에 광고를 부착할 수 있는 다양한 플랫폼이 있다. 그중에서도 Google의 Admob을 이용한 방법을 소개합니다.

Admob 가입하기
https://www.google.co.kr/admob 구글 애드몹 페이지

구글 계정으로 로그인 할 수 있습니다.

광고 생성하기
우선 애드몹 페이지에서 광고를 붙일 앱을 설정합니다. 앱 추가 버튼을 통해 추가할 수 있습니다.


광고를 부착할 앱이 기존에 스토어에 등록되어있던 앱인지, 새로 만들 앱인지 선택합니다. 저는 아직 스토어에 업로드
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Admob" scheme="http://monibu1548.github.io/tags/Admob/"/>
    
      <category term="애드몹" scheme="http://monibu1548.github.io/tags/%EC%95%A0%EB%93%9C%EB%AA%B9/"/>
    
  </entry>
  
  <entry>
    <title>Interface Builder IBOutlet연결에 Strong과 Weak 어떤것을 써야할까?</title>
    <link href="http://monibu1548.github.io/2018/05/03/iboutlet-strong-weak/"/>
    <id>http://monibu1548.github.io/2018/05/03/iboutlet-strong-weak/</id>
    <published>2018-05-03T11:34:36.000Z</published>
    <updated>2018-05-29T12:08:03.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IBOutlet의-Strong-vs-Weak"><a href="#IBOutlet의-Strong-vs-Weak" class="headerlink" title="IBOutlet의 Strong vs Weak"></a>IBOutlet의 Strong vs Weak</h2><p>Interface Builder를 사용하는 프로젝트에서 View를 코드상에서 제어하기 위해 <code>IBOutlet</code>으로 <code>스토리보드</code> <-> <code>코드</code> 를 연결하게 됩니다.<br><code>Ctrl</code>키를 누르고 View를 .m 또는 .h 파일로 가져오면 다음과 같이 IBOutlet 연결 팝업이 뜹니다.<br><img src="../../../../images/iboutlet/1.png" alt=""></-></p><p>여기에서 아마도 Property명 또는 Action명을 입력 후 <code>Connect</code> 버튼을 눌러 커넥션을 생성하셨을텐데요.<br>혹시, 아래쪽의 <code>Storage</code> 영역을 확인해보신적이 있으신가요?</p><p>아마도 디폴트 값은 <code>Weak</code> 일겁니다.</p><p>여기에서 Strong, Weak 는 ARC(Auto Reference Count)와 관련이 깊습니다.<br>Strong, Weak에 대한 자세한 내용은 다른 포스트에서 다루도록 하겠습니다.</p><p>간단히 소개하자면, <code>Strong</code>은 소유대상의 reference count를 1 증가시킴으로써 dealloc 되지 않도록 하고, <code>Weak</code> 는 reference count는 증가시키지 않고 소유함으로써 상호참조 발생을 막아 메모리 누수를 막기위해 사용합니다.</p><h2 id="Dafault는-Weak니까-당연히-Weak을-써야지"><a href="#Dafault는-Weak니까-당연히-Weak을-써야지" class="headerlink" title="Dafault는 Weak니까 당연히 Weak을 써야지?"></a>Dafault는 Weak니까 당연히 Weak을 써야지?</h2><p>네, 아마 커넥션 팝업에서 디폴트로 <code>Weak</code>가 선택되어 있습니다. 왜 <code>Weak</code>가 디폴트일까요?</p><p><code>Strong</code> 으로 사용할 때 문제가 있는지 먼저 살펴보겠습니다.<br><code>ViewController</code>, <code>View</code>, <code>Label</code> 이 3가지 요소로 확인해보도록 하겠습니다.</p><h3 id="IBOutlet에-Strong을-사용한-경우-시나리오"><a href="#IBOutlet에-Strong을-사용한-경우-시나리오" class="headerlink" title="IBOutlet에 Strong을 사용한 경우 시나리오"></a>IBOutlet에 Strong을 사용한 경우 시나리오</h3><p><img src="../../../../images/iboutlet/strong.png" alt=""><br>위 사진과 같이 <code>Strong</code>으로 연결을 한 경우</p><p>Reference Count를 계산해봅시다.</p><ul><li>코드에서 ViewController가 <code>Strong</code>으로 aView를 소유하므로 =&gt; aView:1</li><li>Interface Builder에서 aView가 <code>Label</code> subView로 소유하므로 =&gt; aView:1, Label:1</li><li>코드에서 ViewController가 <code>Strong</code>으로 Label을 소유하므로 =&gt; aView:1, Label:2</li></ul><p>그렇다면 여기에서 메모리 누수가 발생할 가능성이 있을까요?</p><h2 id="ViewController가-dealloc-된다고-가정해보면"><a href="#ViewController가-dealloc-된다고-가정해보면" class="headerlink" title="ViewController가 dealloc 된다고 가정해보면"></a>ViewController가 dealloc 된다고 가정해보면</h2><p>ViewController가 dealloc되는 시나리오로 다시 Reference Count를 계산해봅니다.</p><ul><li>ViewController가 dealloc되므로 소유하고 있던 <code>aView</code>의 reference count를 감소 =&gt; aView:0  (<code>aView의 Reference Count가 0이 되어 dealloc 됩니다</code>)</li><li><code>Label</code>을 소유하던 <code>aView</code>가 dealloc 되므로 <code>Label</code>의 reference Count 감소 =&gt; aView:<code>dealloc 됨</code>, Label:1</li><li>ViewController가 dealloc되므로 소유하고 있던 <code>Label</code> reference Count 감소 =&gt; aView:<code>dealloc 됨</code>, Label:0 <code>Label의 Reference Count가 0이 되어 dealloc 됩니다</code>)</li></ul><p>모두가 깔끔하게 Dealloc 되는 <code>해피앤딩</code> 입니다.<br>이렇듯 IBOutlet에 <code>Strong</code> 을 쓴다고 해서 잘못된 일은 아닙니다.</p><p>오히려 <code>Strong</code>을 써야하는 경우가 있습니다!!!</p><h2 id="IBOutlet에-Strong을-써야-하는-경우"><a href="#IBOutlet에-Strong을-써야-하는-경우" class="headerlink" title="IBOutlet에 Strong을 써야 하는 경우"></a>IBOutlet에 Strong을 써야 하는 경우</h2><p>복잡한 뷰 Hierarchy를 가진 경우에는 <code>Weak</code> 대신 <code>Strong</code>을 써야만 하는 경우도 존재합니다.<br>깊은 뷰 Hierarchy 구조에서 모든 Connection이 <code>Weak</code>라고 한다면 중간쯤 있는 <code>View</code>가 어느 이유에서인지 <code>dealloc</code>이 된다면? 그 하위뷰들도 함께 <code>dealloc</code>이 됩니다.<br>만약 복잡한 뷰 Hierechy 구조상에서 subview의 subview를 사용해야 하는 경우. 의도치 않은 nil을 경험할 수도 있습니다. 일반적이지는 않지만 충분히 겪을 수 있습니다.</p><h2 id="그러면-Strong이-복잡한-Hierarchy에도-문제없고-메모리-누수도-없으니-무조건-Strong을-쓰면-되나요"><a href="#그러면-Strong이-복잡한-Hierarchy에도-문제없고-메모리-누수도-없으니-무조건-Strong을-쓰면-되나요" class="headerlink" title="그러면 Strong이 복잡한 Hierarchy에도 문제없고, 메모리 누수도 없으니 무조건 Strong을 쓰면 되나요?"></a>그러면 Strong이 복잡한 Hierarchy에도 문제없고, 메모리 누수도 없으니 무조건 Strong을 쓰면 되나요?</h2><p><code>아뇨</code></p><p>Default 값이 <code>Weak</code>인 이유가 또 있겠죠. 좀 더 일반적인 상황에서 <code>Weak</code>가 유리한 상황이 존재합니다.</p><p>바로 <code>메모리 부족</code></p><p>메모리가 부족하면 ViewController의 <code>didReceiveMemoryWarning</code>가 호출됩니다.<br>보통 <code>didReceiveMemoryWarning</code> 에서 main view를 <code>nil</code> 처리함으로써 main view를 포함한 subview들 까지 모두 dealloc 하여 메모리를 확보하는 동작을 구현합니다.</p><p>이 경우에 IBOutlet <code>Strong</code> 으로 Subview들을 갖고있다면, ViewController가 <code>Strong</code>으로 갖고있는 <code>Reference Count 1</code> 때문에 절대 최소 1 이하로 내려가질 않습니다.<br>즉, 그 Subview의 ParentView가 nil이 되더라도 SubView는 dealloc되지 않게 됩니다. 보이지도 않는 뷰가 메모리를 차지하게 되어버리는 것이죠.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>디폴트로 <code>Weak</code>을 사용하는게 좋습니다. 그 외 정말 위에서 소개한 특별한 상황 (복잡한 뷰 Hierarchy)를 이해하고 정말 필요할 때 <code>Strong</code>으로 사용하시면 됩니다.</p>]]></content>
    
    <summary type="html">
    
      IBOutlet의 Strong vs Weak
Interface Builder를 사용하는 프로젝트에서 View를 코드상에서 제어하기 위해 IBOutlet으로 스토리보드 코드 를 연결하게 됩니다.
Ctrl키를 누르고 View를 .m 또는 .h 파일로 가져오면 다음과 같이 IBOutlet 연결 팝업이 뜹니다.


여기에서 아마도 Property명 또는 Action명을 입력 후 Connect 버튼을 눌러 커넥션을 생성하셨을텐데요.
혹시, 아래쪽의 Storage 영역을 확인해보신적이 있으신가요?

아마도 디폴트 값은 Weak 일겁니다.

여
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Interface Builder" scheme="http://monibu1548.github.io/tags/Interface-Builder/"/>
    
      <category term="Storyboard" scheme="http://monibu1548.github.io/tags/Storyboard/"/>
    
  </entry>
  
  <entry>
    <title>[Objective-C] NSXMLParser로 XML Object Mapper 구현하기 (공공데이터 Response 파싱하기)</title>
    <link href="http://monibu1548.github.io/2018/05/01/xml-mapper/"/>
    <id>http://monibu1548.github.io/2018/05/01/xml-mapper/</id>
    <published>2018-05-01T14:32:01.000Z</published>
    <updated>2018-05-01T15:40:56.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="공공데이터-Open-API"><a href="#공공데이터-Open-API" class="headerlink" title="공공데이터 Open API"></a>공공데이터 Open API</h2><p><code>data.go.kr</code>에서 다양한 공공데이터 정보를 얻을 수 있습니다. 단순 데이터 파일 또는 Open API형태로 제공하고 있어서 이를 이용해 다양한 서비스를 구현할 수 있습니다.<br>지역 미세먼지 농도, 날씨 예보, 수질 정보 등등 정말 다양한 정보를 얻을 수 있는데요, 스터디용도로 이 API 중 하나를 선택해서 앱을 구현중입니다.</p><h2 id="지방선거-API-활용하기"><a href="#지방선거-API-활용하기" class="headerlink" title="지방선거 API 활용하기"></a>지방선거 API 활용하기</h2><p>가장 최신으로 등록된 API를 찾아보니 곧 6월 13일 지방선거를 앞두고 선거정보, 후보자 정보 Open API가 추가되어서 활용해보기로 했습니다.<br>역시 공공데이터 답게 Response API는 <code>XML</code>을 지원합니다.. 제발 <code>json</code>을 사용해주세요 ㅠㅜ</p><p><code>XML</code> 보다 <code>json</code>을 선호하는 이유는 다음과 같습니다.</p><ul><li><code>json</code>은 dict, list, string, number의 타입으로 구성되어 있죠. Objective-C 에서 사용하는 데이터 타입과 다르지 않아요. 그래서 json을 object로 매핑해주기 편합니다!</li><li><code>xml</code>은 list 타입이 없죠, 같은 depth에 동일한 태그가 여러개 구성되어 있는걸 list라고 판단해야 합니다. 우연히 해당 태그가 1개만 오면 이게 단순 key-value인지 list인지 알 방법이 없죠.</li></ul><h2 id="XML-파싱하기"><a href="#XML-파싱하기" class="headerlink" title="XML 파싱하기"></a>XML 파싱하기</h2><p>Objective-C 에서는 <code>NSXMLParser</code> 라는 클래스를 제공하여 쉽게 XML을 파싱할 수 있도록 도와주고 있습니다.<br>NSXMLParser로 XML을 파싱하는 순서는 다음과 같습니다.</p><ol><li>NSXMLParser에 파싱할 XML데이터 주입</li><li><code>parse</code> 메소드 호출</li><li>NSXMLParser의 델리게이트 호출 (문서 시작, 태그 시작, 태그 끝, 문서 종료 등..)</li></ol><h2 id="NSXMLParser-Delegate"><a href="#NSXMLParser-Delegate" class="headerlink" title="NSXMLParser Delegate"></a>NSXMLParser Delegate</h2><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parserDidStartDocument:(<span class="built_in">NSXMLParser</span> *)parser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 문서가 시작했음을 알리는 Delegate입니다. 처음 1회만 수행합니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName attributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *&gt; *)attributeDict &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;태그&gt;</code> 를 발견했을 때 호출됩니다. elementName값으로 <code>태그</code>가 넘어옵니다.<br><code>&lt;태그 속성=값&gt;</code> 의 형식으로 된 XML태그의 경우 attributes dict 파라미터로 @{ @”속성”, @”값” } 이 전달됩니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didEndElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;/태그&gt;</code> 를 발견했을 때 호출됩니다. elementName 값으로 <code>태그</code>가 넘어옵니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser foundCharacters:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반 문자열을 발견했을 때 호출됩니다.<br><code>&lt;태그&gt;안녕하세요&lt;/태그&gt;</code> 이 경우에 <code>didStartElement</code> 로 <code>태그</code> 값을 읽은 후 <code>foundCharacters</code> 메소드로 안, 녕, 하, 세, 요 가 한글자씩 전달됩니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parserDidEndDocument:(<span class="built_in">NSXMLParser</span> *)parser &#123;</span><br><span class="line">&#125;</span><br><span class="line">XML 문서가 끝났을 때 호출됩니다.</span><br></pre></td></tr></table></figure><ul><li>5개 Delegate 외에 파싱 에러 등 다른 메소드도 있지만 option으로 꼭 구현이 필요하진 않습니다</li></ul><h2 id="XML-Parsing-코드"><a href="#XML-Parsing-코드" class="headerlink" title="XML Parsing 코드"></a>XML Parsing 코드</h2><p>선거 정보 API 에서 내려오는 XML 예제는 다음과 같습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">response</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resultCode</span>&gt;</span>INFO-00<span class="tag">&lt;/<span class="name">resultCode</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resultMsg</span>&gt;</span>NORMAL SERVICE<span class="tag">&lt;/<span class="name">resultMsg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">items</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">num</span>&gt;</span>1<span class="tag">&lt;/<span class="name">num</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgId</span>&gt;</span>20180613<span class="tag">&lt;/<span class="name">sgId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgName</span>&gt;</span>제7회 전국동시지방선거<span class="tag">&lt;/<span class="name">sgName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgTypecode</span>&gt;</span>0<span class="tag">&lt;/<span class="name">sgTypecode</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgVotedate</span>&gt;</span>20180613<span class="tag">&lt;/<span class="name">sgVotedate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">num</span>&gt;</span>2<span class="tag">&lt;/<span class="name">num</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgId</span>&gt;</span>220180613<span class="tag">&lt;/<span class="name">sgId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgName</span>&gt;</span>국회의원선거<span class="tag">&lt;/<span class="name">sgName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgTypecode</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sgTypecode</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sgVotedate</span>&gt;</span>20180613<span class="tag">&lt;/<span class="name">sgVotedate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">items</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">numOfRows</span>&gt;</span>10<span class="tag">&lt;/<span class="name">numOfRows</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pageNo</span>&gt;</span>1<span class="tag">&lt;/<span class="name">pageNo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">totalCount</span>&gt;</span>10<span class="tag">&lt;/<span class="name">totalCount</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">response</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>중간에 <code>&lt;item&gt;</code> 이 엄청 많이 나오는데 list를 표현하기위해 2개만 남기고 나머지는 생략처리했습니다.</li></ul><p>위 XML에 매핑할 Object는 다음과 같이 작성했습니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  EHElectionSchedule.h</span></span><br><span class="line"><span class="comment">//  ElectionHelper</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by JingyuJung on 2018. 4. 29..</span></span><br><span class="line"><span class="comment">//  Copyright © 2018년 JingyuJung. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHElectionSchedule</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *sgId;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sgName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *sgTypecode;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sgVotedate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHElectionSchedule_XMLArray</span> : <span class="title">NSMutableArray</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHElectionScheduleResponseHeader</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *resultCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHElectionScheduleItems</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EHElectionSchedule_XMLArray *item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHElectionScheduleResponseBody</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EHElectionScheduleItems *items;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHElectionScheduleResponse</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EHElectionScheduleResponseHeader *header;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EHElectionScheduleResponseBody *body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHElectionScheduleResponseContainer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EHElectionScheduleResponse *response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>클래스를 읽는 방향은 아래쪽부터 위로 읽어가면 됩니다.<br>규칙은 다음과 같습니다. </p><ul><li>클래스는 XML에서 1 Depth를 의미합니다.</li><li>프로퍼티명은 XML에서 tag 값과 일치해야 합니다.</li><li><code>Array Type</code> 을 표현할 경우 <code>{Array에 담길 클래스}{Array타입임을 알릴 Suffix}</code> 의 클래스를 추가적으로 선언해야 합니다. Suffix에 <code>_XMLArray</code>를 사용한 이유는 Parser코드에서 볼 수 있습니다.</li><li>프로퍼티의 클래스 타입은 Custom, NSString, NSNumber 입니다. (Primitive 타입 지원하지 않습니다.. 못합니다 ㅠㅜ)</li></ul><h2 id="XML-Parser"><a href="#XML-Parser" class="headerlink" title="XML Parser"></a>XML Parser</h2><p>우선 Full Code 입니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  EHXMLSerializer.m</span></span><br><span class="line"><span class="comment">//  ElectionHelper</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by JingyuJung on 2018. 4. 29..</span></span><br><span class="line"><span class="comment">//  Copyright © 2018년 JingyuJung. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"EHXMLSerializer.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHXMLSerializer</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSXMLParser</span> *parser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&gt; *keyStack;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableString</span> *value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Class wrapperClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kEHXMLArraySuffix = <span class="string">@"_XMLArray"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EHXMLSerializer</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Constructor</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">static</span> EHXMLSerializer *shared = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        shared = [[EHXMLSerializer alloc] init];</span><br><span class="line">        [shared EH_initializeXMLParser];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Public</span></span><br><span class="line">- (<span class="keyword">id</span>)modelWithXMLResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    [_parser parse];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private</span></span><br><span class="line">- (<span class="keyword">void</span>)EH_initializeXMLParser &#123;</span><br><span class="line">    _parser = [[<span class="built_in">NSXMLParser</span> alloc] init];</span><br><span class="line">    _parser.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response data:(<span class="built_in">NSData</span> *)data error:(<span class="built_in">NSError</span> *__autoreleasing  _Nullable *)error &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *anError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![_responseClass isSubclassOfClass:<span class="built_in">NSData</span>.class]) &#123;</span><br><span class="line">        <span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line">        <span class="keyword">if</span> (parser &amp;&amp; !anError) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_responseClass) &#123;</span><br><span class="line">                parser.delegate = <span class="keyword">self</span>;</span><br><span class="line">                [parser parse];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSXMLParserDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)parserDidStartDocument:(<span class="built_in">NSXMLParser</span> *)parser &#123;</span><br><span class="line">    _result = [[_responseClass alloc] init];</span><br><span class="line">    _keyStack = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [_keyStack addObject:_result];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName attributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *&gt; *)attributeDict &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *parentObject = _keyStack.lastObject;</span><br><span class="line">    Class propertyClass = [<span class="keyword">self</span> EH_classWithParentObject:parentObject propertyName:elementName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyClass) &#123;</span><br><span class="line">        <span class="keyword">id</span> childObject;</span><br><span class="line">        <span class="keyword">if</span> (propertyClass == [<span class="built_in">NSNumber</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            <span class="comment">// NSNumber의 경우 init 제공 X =&gt; nil 방지처리</span></span><br><span class="line">            childObject = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>(propertyClass) hasSuffix:kEHXMLArraySuffix]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *elementClassString = [<span class="built_in">NSStringFromClass</span>(propertyClass) stringByReplacingOccurrencesOfString:kEHXMLArraySuffix withString:<span class="string">@""</span>];</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *array = [parentObject valueForKey:elementName];</span><br><span class="line">            <span class="keyword">if</span> (![array isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [_keyStack addObject:[<span class="built_in">NSMutableArray</span> array]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [_keyStack addObject:array];</span><br><span class="line">            &#125;</span><br><span class="line">            propertyClass = <span class="built_in">NSClassFromString</span>(elementClassString);</span><br><span class="line">            childObject = [[propertyClass alloc] init];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            childObject = [[propertyClass alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        [_keyStack addObject:childObject];</span><br><span class="line">        _value = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didEndElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *parentObject = [_keyStack objectAtIndex:_keyStack.count - <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *wrapperArray;</span><br><span class="line">    <span class="built_in">BOOL</span> isArrayType = [parentObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]];</span><br><span class="line">    <span class="keyword">if</span> (isArrayType) &#123;</span><br><span class="line">        wrapperArray = (<span class="built_in">NSMutableArray</span> *)parentObject;</span><br><span class="line">        parentObject = [_keyStack objectAtIndex:_keyStack.count - <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class propertyClass = [<span class="keyword">self</span> EH_classWithParentObject:parentObject propertyName:elementName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!propertyClass) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> value = [_value length] ? _value : _keyStack.lastObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isArrayType) &#123;</span><br><span class="line">        [(<span class="built_in">NSMutableArray</span> *)wrapperArray addObject:_keyStack.lastObject];</span><br><span class="line">        [_keyStack removeLastObject];</span><br><span class="line">        value = wrapperArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [parentObject setValue:value forKey:elementName];</span><br><span class="line">    [_keyStack removeLastObject];</span><br><span class="line">    _value = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser foundCharacters:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    [_value appendString:string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)parserDidEndDocument:(<span class="built_in">NSXMLParser</span> *)parser &#123;</span><br><span class="line">    _result = _keyStack.firstObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)EH_classWithParentObject:(<span class="built_in">NSObject</span> *)object propertyName:(<span class="built_in">NSString</span> *)propertyName &#123;</span><br><span class="line">    </span><br><span class="line">    Class objectClass = object.class;</span><br><span class="line">    Class result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> propertiesCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(objectClass, &amp;propertiesCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; propertiesCount; index++) &#123;</span><br><span class="line">        objc_property_t property = properties[index];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *cname = property_getName(property);</span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:cname];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([name isEqualToString:propertyName]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *type = property_getAttributes(property);</span><br><span class="line">            <span class="built_in">NSString</span> *typeString = [<span class="built_in">NSString</span> stringWithUTF8String:type];</span><br><span class="line">            <span class="built_in">NSArray</span> *attributes = [typeString componentsSeparatedByString:<span class="string">@","</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *typeAttribute = [attributes objectAtIndex:<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *propertyType = [typeAttribute substringFromIndex:<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *propertyClass = [<span class="keyword">self</span> EH_removeNotNeededChar:propertyType];</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">NSClassFromString</span>(propertyClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(properties);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)EH_removeNotNeededChar:(<span class="built_in">NSString</span> *)originString &#123;</span><br><span class="line">    <span class="keyword">if</span> (originString.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([[originString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">2</span>)] isEqualToString:<span class="string">@"@\""</span>] &amp;&amp;</span><br><span class="line">        [[originString substringWithRange:<span class="built_in">NSMakeRange</span>(originString.length - <span class="number">1</span>, <span class="number">1</span>)] isEqualToString:<span class="string">@"\""</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [originString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, originString.length - <span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>이제 구간별로 살펴보겠습니다.</p><ul><li>라인 : <code>13 - 23</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EHXMLSerializer</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSXMLParser</span> *parser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&gt; *keyStack;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableString</span> *value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Class wrapperClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ul><p>parser는 파싱을 수행할 parser<br>keyStack은 태그를 읽어나가면서 Depth를 관리하기 위한 Stack 입니다<br>value는 태그의 값을 관리하기 위한 MutableString 입니다<br>wrapperClass는 array 타입으로 된 부분을 파싱하기 위한 프로퍼티입니다<br>result는 최종 파싱 결과물이 될 프로퍼티입니다.</p><ul><li>라인 : <code>17 - 42</code></li></ul><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kEHXMLArraySuffix = <span class="string">@"_XMLArray"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EHXMLSerializer</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Constructor</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">static</span> EHXMLSerializer *shared = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        shared = [[EHXMLSerializer alloc] init];</span><br><span class="line">        [shared EH_initializeXMLParser];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shared;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@&quot;_XMLArray&quot;</code> 는 해당 클래스가 XML을 파싱할 때 Array 타입으로 해야한다는 걸 알리기 위해 Model 작성할 때 명시적으로 붙였던 Suffix 입니다.<br><code>serialilzer</code> 는 GCD를 이용해 싱글톤으로 구현한 생성자입니다.</p><ul><li>라인 : <code>56 - 69</code></li></ul><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response data:(<span class="built_in">NSData</span> *)data error:(<span class="built_in">NSError</span> *__autoreleasing  _Nullable *)error &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *anError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![_responseClass isSubclassOfClass:<span class="built_in">NSData</span>.class]) &#123;</span><br><span class="line">        <span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line">        <span class="keyword">if</span> (parser &amp;&amp; !anError) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_responseClass) &#123;</span><br><span class="line">                parser.delegate = <span class="keyword">self</span>;</span><br><span class="line">                [parser parse];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>response 로 받아온 XML Data를 이용해서 외부에서 호출하는 메소드입니다.<br>외부에서 이 메소드를 호출하기 전에 <code>responseClass</code>에 이 XML에 매핑할 클래스를 <code>set</code> 해주는 과정이 꼬오옥 필요합니다.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[EHXMLSerializer serializer] setResponseClass:[EHElectionScheduleResponseContainer <span class="keyword">class</span>]];</span><br><span class="line">        EHElectionScheduleResponseContainer *container = [[EHXMLSerializer serializer] responseObjectForResponse:response data:responseObject error:&amp;error];</span><br></pre></td></tr></table></figure><p>API 호출을 완료한 후 Model에 Mapping 하기 위해 Parser호출하는 부분</p><p><code>[parser parse]</code>에 의해 파싱이 시작됩니다.</p><ul><li>라인 : <code>73 - 77</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parserDidStartDocument:(<span class="built_in">NSXMLParser</span> *)parser &#123;</span><br><span class="line">    _result = [[_responseClass alloc] init];</span><br><span class="line">    _keyStack = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [_keyStack addObject:_result];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>XML 문서 파싱을 시작할 때 호출됩니다. 파싱에 필요한 프로퍼티들을 초기화합니다. 가장 첫번째 Response 객체를 keyStack에 담는것으로 파싱을 시작합니다.</p><ul><li>라인 : <code>79 - 105</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName attributes:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *&gt; *)attributeDict &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *parentObject = _keyStack.lastObject;</span><br><span class="line">    Class propertyClass = [<span class="keyword">self</span> EH_classWithParentObject:parentObject propertyName:elementName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propertyClass) &#123;</span><br><span class="line">        <span class="keyword">id</span> childObject;</span><br><span class="line">        <span class="keyword">if</span> (propertyClass == [<span class="built_in">NSNumber</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            childObject = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>(propertyClass) hasSuffix:kEHXMLArraySuffix]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *elementClassString = [<span class="built_in">NSStringFromClass</span>(propertyClass) stringByReplacingOccurrencesOfString:kEHXMLArraySuffix withString:<span class="string">@""</span>];</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *array = [parentObject valueForKey:elementName];</span><br><span class="line">            <span class="keyword">if</span> (![array isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [_keyStack addObject:[<span class="built_in">NSMutableArray</span> array]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [_keyStack addObject:array];</span><br><span class="line">            &#125;</span><br><span class="line">            propertyClass = <span class="built_in">NSClassFromString</span>(elementClassString);</span><br><span class="line">            childObject = [[propertyClass alloc] init];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            childObject = [[propertyClass alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        [_keyStack addObject:childObject];</span><br><span class="line">        _value = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>XML 에서 태그를 발견하면 keyStack의 lastObject (1 depth 상위 클래스) 에 포함된 프로퍼티인지 확인합니다. 없다면 굳이 매핑이 필요없으므로 패스!<br>포함되어있다면 해당 프로퍼티의 클래스를 판별하고 할당하여 keyStack에 담아둡니다. <code>_value</code> NSMutableString 을 할당하여 값을 읽을 준비를 합니다.</p><ul><li>라인 : <code>136 - 138</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser foundCharacters:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    [_value appendString:string];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>태그 사이의 값들을 <code>_value</code> 에  appending해 나가면서 값을 완성시켜 나갑니다.</p><ul><li>라인 : <code>107 - 134</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didEndElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *parentObject = [_keyStack objectAtIndex:_keyStack.count - <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *wrapperArray;</span><br><span class="line">    <span class="built_in">BOOL</span> isArrayType = [parentObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]];</span><br><span class="line">    <span class="keyword">if</span> (isArrayType) &#123;</span><br><span class="line">        wrapperArray = (<span class="built_in">NSMutableArray</span> *)parentObject;</span><br><span class="line">        parentObject = [_keyStack objectAtIndex:_keyStack.count - <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class propertyClass = [<span class="keyword">self</span> EH_classWithParentObject:parentObject propertyName:elementName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!propertyClass) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> value = [_value length] ? _value : _keyStack.lastObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isArrayType) &#123;</span><br><span class="line">        [(<span class="built_in">NSMutableArray</span> *)wrapperArray addObject:_keyStack.lastObject];</span><br><span class="line">        [_keyStack removeLastObject];</span><br><span class="line">        value = wrapperArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [parentObject setValue:value forKey:elementName];</span><br><span class="line">    [_keyStack removeLastObject];</span><br><span class="line">    _value = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>태그가 끝나면 keyStack의 마지막 object에 값을 KVC로 셋하고 _keyStack에서 완성된 lastObject를 제거합니다.<br>만약 부모클래스가 Array 타입이었다면 현재 완성된 클래스를 Array에 추가시켜줍니다.</p><ul><li>라인 : <code>140 - 142</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)parserDidEndDocument:(<span class="built_in">NSXMLParser</span> *)parser &#123;</span><br><span class="line">    _result = _keyStack.firstObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>XML 문서가 끝나면 최종적으로 keyStack에는 최상위 클래스가 남게됩니다. 따라서 result에 _keyStack의 firstObject를 연결합니다.</p><ul><li>라인 : <code>144 - 172</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (Class)EH_classWithParentObject:(<span class="built_in">NSObject</span> *)object propertyName:(<span class="built_in">NSString</span> *)propertyName &#123;</span><br><span class="line">    </span><br><span class="line">    Class objectClass = object.class;</span><br><span class="line">    Class result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> propertiesCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(objectClass, &amp;propertiesCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; propertiesCount; index++) &#123;</span><br><span class="line">        objc_property_t property = properties[index];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *cname = property_getName(property);</span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:cname];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([name isEqualToString:propertyName]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *type = property_getAttributes(property);</span><br><span class="line">            <span class="built_in">NSString</span> *typeString = [<span class="built_in">NSString</span> stringWithUTF8String:type];</span><br><span class="line">            <span class="built_in">NSArray</span> *attributes = [typeString componentsSeparatedByString:<span class="string">@","</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *typeAttribute = [attributes objectAtIndex:<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *propertyType = [typeAttribute substringFromIndex:<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *propertyClass = [<span class="keyword">self</span> EH_removeNotNeededChar:propertyType];</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">NSClassFromString</span>(propertyClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(properties);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>해당 obejct에 propertyName이라는 변수명을 가진 프로퍼티의 클래스를 리턴해주는 함수입니다.<br>Objective-C의 인스트로펙션, 자바에서 리플렉션이라 불리는 기능을 이용해 구현합니다.</p><ul><li>라인 : <code>174 - 183</code><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)EH_removeNotNeededChar:(<span class="built_in">NSString</span> *)originString &#123;</span><br><span class="line">    <span class="keyword">if</span> (originString.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([[originString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">2</span>)] isEqualToString:<span class="string">@"@\""</span>] &amp;&amp;</span><br><span class="line">        [[originString substringWithRange:<span class="built_in">NSMakeRange</span>(originString.length - <span class="number">1</span>, <span class="number">1</span>)] isEqualToString:<span class="string">@"\""</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [originString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, originString.length - <span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>runtime 메소드를 이용해 property의 클래스 타입을 가져왔을 때, @\”\” 의 불필요한 문자열이 추가되기 때문에 제거를 위해 만든 함수입니다.</p><h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><p>위에서 만든 XMl Serializer를 이용해 XML을 매핑하면 다음과 같은 결과를 얻을 수 있습니다.<br><img src="../../../../images/xmlparser/1.png" alt=""></p><p><code>더 보완이 필요한 내용</code></p><ul><li>현재 최종 마지막 타입은 <code>NSString</code> 과 <code>NSNumber</code> 만 지원하고 있는데, <code>NSDate</code> 도 추가가 필요합니다!</li></ul>]]></content>
    
    <summary type="html">
    
      공공데이터 Open API
data.go.kr에서 다양한 공공데이터 정보를 얻을 수 있습니다. 단순 데이터 파일 또는 Open API형태로 제공하고 있어서 이를 이용해 다양한 서비스를 구현할 수 있습니다.
지역 미세먼지 농도, 날씨 예보, 수질 정보 등등 정말 다양한 정보를 얻을 수 있는데요, 스터디용도로 이 API 중 하나를 선택해서 앱을 구현중입니다.

지방선거 API 활용하기
가장 최신으로 등록된 API를 찾아보니 곧 6월 13일 지방선거를 앞두고 선거정보, 후보자 정보 Open API가 추가되어서 활용해보기로 했습니다.
역시
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Objective-C" scheme="http://monibu1548.github.io/categories/iOS/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Reflection" scheme="http://monibu1548.github.io/tags/Reflection/"/>
    
      <category term="스터디" scheme="http://monibu1548.github.io/tags/%EC%8A%A4%ED%84%B0%EB%94%94/"/>
    
      <category term="XML Parser" scheme="http://monibu1548.github.io/tags/XML-Parser/"/>
    
      <category term="NSXMLParser" scheme="http://monibu1548.github.io/tags/NSXMLParser/"/>
    
  </entry>
  
  <entry>
    <title>[Objective-C] reflection(리플렉션), Introspection(인트로스펙션) Runtime 메소드 사용하기</title>
    <link href="http://monibu1548.github.io/2018/05/01/objc-runtime/"/>
    <id>http://monibu1548.github.io/2018/05/01/objc-runtime/</id>
    <published>2018-05-01T14:18:43.000Z</published>
    <updated>2018-05-01T15:36:17.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p>Objective-C에서 자바의 Reflection 에 해당하는 기능을 Introspection(인트로스펙션) 이라고 합니다.<br>이 기능들은 <code>&lt;objc/runtime.h&gt;</code> 헤더 파일에 선언되어 있으며, C 함수로 작성되어 있습니다.</p><p>사용할 수 있는 메소드는 애플 개발자 센터 가이드에서 확인 가능합니다.<br><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc" target="_blank" rel="noopener">애플 개발자 센터 Runtime 개발 가이드</a><br>가이드 문서에서 확인할 수 있듯이 수십여 가지의 메소드로 다양한 인스트로펙션 기능을 제공하고 있습니다.</p><p>Introspection을 이용해서 다양한 기능을 구현할 수 있습니다.</p><ol><li>특정 객체가 특정 Protocol, Method이 있는지 조사하여 앱 크래시 방지</li><li>외부 API Response로 내려온 json, XML 등을 Object Model 에 매핑할 때</li></ol><h2 id="Instropection을-이용한-XMl-Object-Mapper-구현예제"><a href="#Instropection을-이용한-XMl-Object-Mapper-구현예제" class="headerlink" title="Instropection을 이용한 XMl Object Mapper 구현예제"></a>Instropection을 이용한 XMl Object Mapper 구현예제</h2><p>스터디용으로 공공데이터를 이용한 앱을 만드는 작업을 하고 있는데, 대부분의 Response형태가 <code>XML</code>로 되어 있습니다. <code>json</code> 이면 좋을텐데 ㅠㅜ<br><a href="http://monibu1548.github.io/2018/05/01/xml-mapper/">NSXMLParser로 XML Object Mapper 구현하기 (공공데이터 Response 파싱하기) 포스트 보러가기</a></p><h2 id="Parser에서-사용한-Instropection"><a href="#Parser에서-사용한-Instropection" class="headerlink" title="Parser에서 사용한 Instropection"></a>Parser에서 사용한 Instropection</h2><h3 id="class-copy-PropertyList-Class-int"><a href="#class-copy-PropertyList-Class-int" class="headerlink" title="class_copy_PropertyList(Class, int *)"></a>class_copy_PropertyList(Class, int *)</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> propertiesCount = <span class="number">0</span>;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(objectClass, &amp;propertiesCount);</span><br></pre></td></tr></table></figure><p>objectClass클래스가 가진 objc_property_t 구조체들을 array로 리턴하며 배열 갯수는 propertiesCount에 담겨집니다.<br>이렇게 반환된 <code>properties</code> 변수는 나중에 반드시 <code>free(properties)</code> 호출되어야 합니다.</p><h3 id="property-getName-objc-property-t"><a href="#property-getName-objc-property-t" class="headerlink" title="property_getName(objc_property_t)"></a>property_getName(objc_property_t)</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cname = property_getName(property);</span><br><span class="line"><span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:cname];</span><br></pre></td></tr></table></figure><p>프로퍼티의 이름 (클래스) 이름을 const char 타입으로 리턴합니다.<br>NSString의 stringWithUTF8String을 통해 NSString으로 wrapping 가능 합니다.</p><p>… 추가 작성 예정</p>]]></content>
    
    <summary type="html">
    
      Reflection
Objective-C에서 자바의 Reflection 에 해당하는 기능을 Introspection(인트로스펙션) 이라고 합니다.
이 기능들은 &lt;objc/runtime.h&gt; 헤더 파일에 선언되어 있으며, C 함수로 작성되어 있습니다.

사용할 수 있는 메소드는 애플 개발자 센터 가이드에서 확인 가능합니다.
애플 개발자 센터 Runtime 개발 가이드
가이드 문서에서 확인할 수 있듯이 수십여 가지의 메소드로 다양한 인스트로펙션 기능을 제공하고 있습니다.

Introspection을 이용해서 다양한 기능을 구현할 수 있
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="Objective-C" scheme="http://monibu1548.github.io/categories/iOS/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://monibu1548.github.io/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://monibu1548.github.io/tags/Runtime/"/>
    
      <category term="Reflection" scheme="http://monibu1548.github.io/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>XCode Server를 이용한 CI(continuous integration)</title>
    <link href="http://monibu1548.github.io/2018/04/25/xcode-server-intro/"/>
    <id>http://monibu1548.github.io/2018/04/25/xcode-server-intro/</id>
    <published>2018-04-25T13:29:35.000Z</published>
    <updated>2018-05-29T12:05:30.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CI-란"><a href="#CI-란" class="headerlink" title="CI 란?"></a>CI 란?</h2><p>CI란 <code>continuous integration</code>의 약자로 지속적 통합을 뜻한다. 작업을 작은 단위로 쪼갠 뒤, 작은 단위로 개발, 지속적으로 통합하는 과정을 통한 개발 방법으로 코드 품질향상, 배포주기 단축을 목표로 한다.</p><h2 id="iOS에서의-CI"><a href="#iOS에서의-CI" class="headerlink" title="iOS에서의 CI"></a>iOS에서의 CI</h2><p>iOS 앱은 실행파일(.ipa) 하나를 Export 하는데에 인증서, 프로비저닝 등 빌드 과정에 관여하는 변수가 많아 CI를 적용하기가 까다로운 편이다.</p><p>작년까지만 해도 <code>Jenkins</code>에 <code>Xcode Plugin</code>을 붙여 빌드를 진행하고 , 그 외 OTA를 위한 manifest, archive, export, OTA 배포까지의 과정은 Shell Script를 이용해 수동으로 작업했다.</p><p>물론, 한번 세팅해두면 이후에는 손 볼 일이 거의 없긴하다.</p><p><code>그러던 어느날</code>, 앱 인증서가 만료되어, 프로비저닝과 인증서를 교체해야 하는 일이 생겼다.</p><h2 id="Jenkins에서-인증서-프로비저닝-갱신하기"><a href="#Jenkins에서-인증서-프로비저닝-갱신하기" class="headerlink" title="Jenkins에서 인증서, 프로비저닝 갱신하기"></a>Jenkins에서 인증서, 프로비저닝 갱신하기</h2><ul><li>Apple developer 사이트에서 새로운 인증서와 프로비저닝을 다운로드 받는다.</li><li>jenkins credential 페이지에서 인증서와 프로비저닝을 업로드 한다.</li><li>프로젝트 Plugin 에서 새로운 인증서와, 프로비저닝을 선택해준다.</li><li>ipa export 하는 과정에서 프로비저닝 이름을 수동으로 입력해준다.</li></ul><p><code>=&gt; 수동으로 해야할 일이 꽤 많다</code></p><p>사실 프로젝트 1개만 있으면 문제가 없다.</p><p>그런데 나는..? 프로젝트가 3개가 있다.. 그것도 dev와 appstore로 구분하면 x2, 총 6개.</p><p>이 작업을 하면서, 아 이건 아니다 싶었고 다른 CI툴을 찾아 나섰고.</p><p>마침 XCode9 가 등장하면서 XCode Server가 무료로 내장되어 업데이트 되어 XCode Server를 사용해보기로 했다.</p><h2 id="XCode-Server-설치하기"><a href="#XCode-Server-설치하기" class="headerlink" title="XCode Server 설치하기"></a>XCode Server 설치하기</h2><p>사실 설치라고 할 게 없다. XCode9 를 설치하면 XCodeServer가 내장되어 있다.<br>그렇다면 XCode Server를 활성화 시켜보자.</p><p><code>XCode</code> -&gt; <code>Preference</code> -&gt; <code>Server &amp; Bots</code><br><img src="../../../../images/xcodeserver/make1.png" alt=""></p><p>off -&gt; <code>on</code> 으로 활성화 시키자.</p><p>XCode Server의 관리자 계정을 설정하고 Next를 누르다 보면<br><img src="../../../../images/xcodeserver/make2.png" alt=""></p><p><code>끝</code></p><p><code>setting</code> : 서버 계정, 빌드 타임아웃 시간 설정<br><code>permission</code> : 봇을 생성하고 볼 수 있는 권한 설정<br><code>mail</code> : 빌드 과정에서 메일 알람을 주기 위한 메일 설정</p><p>이제 서버가 할 일은 끝났다.</p><h2 id="XCodeServer에-접속하기"><a href="#XCodeServer에-접속하기" class="headerlink" title="XCodeServer에 접속하기"></a>XCodeServer에 접속하기</h2><p>지금까지는 XCode Server를 활성화 하는 과정이었다.<br>이제 XCode에 XCode Server를 연동하여 사용하는 과정을 소개한다.</p><p>우선 XCode에 XCode Server를 연결한다.<br><code>XCode</code> -&gt; <code>Preference</code> -&gt; <code>Accounts</code><br><img src="../../../../images/xcodeserver/make3.png" alt=""></p><p>우측 하단의 <code>+</code> 를 눌러보자.</p><p><img src="../../../../images/xcodeserver/make4.png" alt=""></p><p>하단의 XCode Server 를 추가할 수 있도록 되어있다.</p><p><img src="../../../../images/xcodeserver/make5.png" alt=""></p><p>같은 맥에 XCode Server와 XCode를 구동하기 때문에 위 사진처럼 바로 목록이 뜨지만. XCode Server가 원격지에 있다면 ip를  직접 입력해줘야 한다.</p><p>그 후 XCode Server에서 권한을 부여받은 계정을 입력해주면 끝!</p><p><img src="../../../../images/xcodeserver/make6.png" alt=""></p><p>대화상자 하단에 XCode Server의 스펙을 볼 수 있다.</p><h2 id="Build-Bot-만들기"><a href="#Build-Bot-만들기" class="headerlink" title="Build Bot 만들기"></a>Build Bot 만들기</h2><p>위 과정을 통해 XCode Server를 정상적으로 추가했다면 Build Bot을 생성할 수 있다.<br>XCode Server에서는 빌드는 모두 Bot이라는 단위로 실행되며 Bot은 프로젝트 빌드 타겟과 매칭된다고 보면 된다.</p><p>이제 Bot을 만들어보자.</p><p>XCode에서 <code>Product</code> -&gt; <code>Create Bot...</code> 를 선택한다.<br><img src="../../../../images/xcodeserver/make7.png" alt=""></p><p>봇의 이름과 봇을 생성할 서버를 선택한다.<br>봇의 이름은 <code>한글</code> 도 가능하다.</p><p><img src="../../../../images/xcodeserver/make8.png" alt=""><br>봇을 생성하려는 프로젝트가 git을 사용중이라면 그 내용을 자동으로 긁어온다.<br>현재 빨간색으로 <code>레포지토리 권한이 없습니다</code> 라고 뜨는데 오른쪽의 <code>Sign in</code> 으로 레포지토리 로그인을 하면 해결된다.</p><p><img src="../../../../images/xcodeserver/make9.png" alt=""><br>로그인을 완료하면 브랜치를 선택 가능하다. CI에 사용할 브랜치를 선택한다.</p><p><img src="../../../../images/xcodeserver/make10.png" alt=""><br>프로젝트의 Scheme, Configuration 을 설정할 수 있으며 Analyze 또는 Test도 선택적으로 수행 가능하다.<br>Archive도 제공하며 ipa 까지 추출하기 위해서는 별도의 ExportOptions.plist가 필요하다.</p><p><img src="../../../../images/xcodeserver/make11.png" alt=""><br>빌드 시간과, Clean시점을 설정할 수 있어서 주기적으로 정해진 시간에 빌드를 진행, 배포할 수 있다.<br>선택 옵션은 <code>Preiodically</code>, <code>on commit</code>, <code>maually</code> 이 있어서 수동 빌드도 가능하다.</p><p><img src="../../../../images/xcodeserver/make12.png" alt=""><br><code>여기가 진정한 XCode Server의 꽃이다</code></p><p>XCode에 연결된 계정에서 사용 가능한 인증서와 프로비저닝 목록을 한번에 볼 수 있으며 빌드에 필요한 인증서와 프로비저닝을 선택하여 <code>Add to server</code> 만 선택하면 빌드서버에 자동으로 등록 설치된다.</p><ul><li>Jenkins에서 이 작업이 얼마나 번거로웠는지,,,,,</li></ul><p><img src="../../../../images/xcodeserver/make13.png" alt=""><br>빌드 과정에서 사용할 환경변수를 지정할 수 있다.</p><p><img src="../../../../images/xcodeserver/make14.png" alt=""><br>마지막 관문이다.<br>빌드를 시작할 때 Slack에 보내고 빌드가 끝나면 빌드 파일을 Slack으로 보내고! 이런 작업이 필요한데<br>바로 여기서 설정 할 수 있다.</p><p>왼쪽 하단의 <code>+</code> 버튼을 누르면 다양한 스크립트를 추가할 수 있다.</p><ul><li>빌드 시작</li><li>빌드 종료</li><li>메일 전송</li></ul><p>등 다양한 상황이 존재하며, 해당 상황에 적절한 스크립트를 통해 여러가지 기능을 확장 할 수 있다.<br><code>cocoaPod</code> 을 사용한다면 <code>Pre-Integration</code> 스크립트에 <code>Pod install</code> 을 추가해주자.</p><p><code>끝</code></p><h2 id="Bot을-만들었으면-사용해야지"><a href="#Bot을-만들었으면-사용해야지" class="headerlink" title="Bot을 만들었으면 사용해야지"></a>Bot을 만들었으면 사용해야지</h2><p>Bot을 만들었는데 어디에 있는 것일까?!</p><p><img src="../../../../images/xcodeserver/make15.png" alt=""><br><code>얍짠</code></p><p><img src="../../../../images/xcodeserver/make16.png" alt=""><br>봇의 상세화면이다. 다음의 내용을 확인 할 수 있다.</p><ul><li>테스트 성공률</li><li>Warning 수</li><li>이전 빌드보다 추가된 커밋 수</li><li>이전 빌드 이후 제거된 warning들</li><li>코드 커버리지</li><li>archive 했다면 archive file</li><li>export 했다면 ipa file</li></ul><p><code>짱이다</code></p><p>빌드를 한번 해보자. 우측 상단의 <code>Integrate</code> 버튼을 눌러보자.</p><h2 id="Jenkins-vs-XCodeServer"><a href="#Jenkins-vs-XCodeServer" class="headerlink" title="Jenkins  vs  XCodeServer"></a>Jenkins  vs  XCodeServer</h2><p>Jenkins와 XCodeServer를 사용해보면서 느낀 특징, 장단점은 다음과 같다.</p><ul><li><p>Jenkins</p><ul><li>장점<ul><li>Github과 연동이 잘된다. Hook을 통해 PR, Commit 등 다양한 상황과 연동 가능하다</li></ul></li><li>단점<ul><li>XCode8 이후로 ipa 추출하는 과정에서 ExportOptions.plist 가 추가적으로 필요하게 되었는데 아직 이를 자동으로 해주는 플러그인이 없다.</li><li>인증서, 프로비저닝 갱신 과정이 번거롭다.</li></ul></li></ul></li><li><p>XCodeServer</p><ul><li>장점<ul><li>XCode와의 연동이 최고다. 인증서, 프로비저닝 관리가 가장 깔끔하다.</li><li>빌드를 위해 별도의 웹 페이지에 접속할 필요가 없다.</li><li>OTA 기능도 지원한다 (근데 사실상 사용 불가… 애플놈들…)</li></ul></li><li>단점<ul><li>Github과의 연동이 약하다. PR을 통한 Test를 진행하는 프로젝트에서는 바로 적용이 힘들다.</li><li>아직 안정화가 될 되었다. 작은 버그들이 우수수수….</li></ul></li></ul></li></ul><p>결론적으로, <code>XCode Server</code> 를 선택해서 사용중이며 만족하면서 사용하고 있습니다~!</p><h2 id="그-외의-iOS-CI-툴"><a href="#그-외의-iOS-CI-툴" class="headerlink" title="그 외의 iOS CI 툴"></a>그 외의 iOS CI 툴</h2><p><code>fastlane</code>이라는게 있답니다..! </p>]]></content>
    
    <summary type="html">
    
      CI 란?
CI란 continuous integration의 약자로 지속적 통합을 뜻한다. 작업을 작은 단위로 쪼갠 뒤, 작은 단위로 개발, 지속적으로 통합하는 과정을 통한 개발 방법으로 코드 품질향상, 배포주기 단축을 목표로 한다.

iOS에서의 CI
iOS 앱은 실행파일(.ipa) 하나를 Export 하는데에 인증서, 프로비저닝 등 빌드 과정에 관여하는 변수가 많아 CI를 적용하기가 까다로운 편이다.

작년까지만 해도 Jenkins에 Xcode Plugin을 붙여 빌드를 진행하고 , 그 외 OTA를 위한 manifest, arc
    
    </summary>
    
      <category term="iOS" scheme="http://monibu1548.github.io/categories/iOS/"/>
    
      <category term="공통" scheme="http://monibu1548.github.io/categories/iOS/%EA%B3%B5%ED%86%B5/"/>
    
    
      <category term="XCodeServer" scheme="http://monibu1548.github.io/tags/XCodeServer/"/>
    
      <category term="XCode" scheme="http://monibu1548.github.io/tags/XCode/"/>
    
      <category term="생산성" scheme="http://monibu1548.github.io/tags/%EC%83%9D%EC%82%B0%EC%84%B1/"/>
    
  </entry>
  
</feed>
